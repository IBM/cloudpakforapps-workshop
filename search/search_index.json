{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Creating Cloud Native Applications with Cloud Pak for Applications on OpenShift \u00b6 Welcome to our workshop! In this workshop we'll be using the Cloud Pak for Applications platform to create Cloud Native Applications that run on OpenShift. The goals of this workshop are: Use Appsody and Codewind to create a cloud native application Create a custom Collection Use Tekton CI to continuously deploy to OpenShift About this workshop \u00b6 The introductory page of the workshop is broken down into the following sections: Agenda Compatability About Cloud Pak for Applications Credits Agenda \u00b6 Day 1: Kabanero and Appsody for Developers and Operators \u00b6 In this first day we'll learn how to use Appsody to run the inner loop of the development and test cycle for a developer, and how these tools can be integrated into your favorite IDE. We'll also explore how to deploy an application to OpenShift, first manually with Appsody for dev/test purposes, and then using the standard Kabanero Tekton piplines with GitOps as part of a continual test/production cycle. Lecture 1: What is Cloud Native? Learn about the technologies that underpin Cloud Native applications Lecture 2: Kabanero Overview Learn about Kabanero. An open source project to rapidly create Cloud Native applications Exercise 1: Introduction to Appsody and Codewind Install the Appsody component of Kabanero into the IDE with Codewind, Learn about the developer flow, building your first application with Appsody Exercise 2: Using Appsody CLI to develop, test, and debug applications Use the Appsody CLI to quickly create frontend and backend applications for a sample application using two different technologies (Spring and nodejs express) Exercise 3: Deploying to OpenShift with Appsody Deploy the built applications to IBM Managed OpenShift with Appsody for dev/test purposes Lecture 3: Adding value with IBM Cloud Pak for Applications Learn about how IBM Cloud Pak for Applications bundles everything together Exercise 4: Use Tekton and Kabanero Pipelines to continuously deploy Deploy the built applications to IBM Managed OpenShift using GitOps to trigger a Tekton pipeline Day 2: Customizing Stacks, Pipelines in Collections \u00b6 In the second day we'll learn about the Kabanero open source project and how to productionize our applications with custom Appsody Stacks, custom Collections, and custom Tekton pipelines. Lecture 4: Customizing Appsody and Kabanero Learn all about the stacks and repos Exercise 6: Building a custom Collection Create a collection that will contain custom appsody stacks and pipelines Exercise 5: Customizing an existing Appsody Stack Create a custom stack, to be hosted in our custom repository Exercise 7: Using a custom Collection with Appsody Learn how to manage these custom stacks and how to make them available to developers Lecture 5: Tekton Overview Learn all Tekton CI/CD and how Kabanero uses it Exercise 8: Create a custom Tekton Task and Pipleline Build a pipeline that will fit into a custom Collection Exercise 9: Deploy an application with a custom Stack, custom Collection, and custom Pipeline Build and deploy an application using the custom stack, collection and pipelines built by the Architects' and Operators' tracks Compatability \u00b6 This workshop has been tested on the following platforms: macOS : Mojave (10.14), Catalina (10.15) Windows Windows 10 (with enterprise AAD and git bash) About Cloud Pak for Applications \u00b6 IBM Cloud Pak for Applications is an enterprise-ready, containerized software solution for modernizing existing applications and developing new cloud-native apps that run on Red Hat\u00ae OpenShift\u00ae. Built on IBM WebSphere offerings and Red Hat OpenShift Container Platform with the Kabanero open source project, Cloud Pak for Applications provides a long-term solution to help you transition between public, private, and hybrid clouds, and create new business applications. A few other noteworthy mentions \u00b6 Cloud Pak for Applications: ... includes the Kabanero open source project WebSphere Mobile Foundation IBM Cloud Private Transformation Advisory ...and more ... can be deployed on any major cloud provider supporting OpenShift (IBM Cloud, AWS, Azure, GCP) Credits \u00b6 This workshop was primarily written by Henry Nash and Steve Martinelli . Many other IBMers have contributed to help shape, test, and contribute to the workshop. Greg Dritschler : For his Insurance Quote Code Pattern Carlos Santana : For his Learning Kabanero 101 Tutorial Tim Robinson : For testing the lab on Windows","title":"About the workshop"},{"location":"#creating-cloud-native-applications-with-cloud-pak-for-applications-on-openshift","text":"Welcome to our workshop! In this workshop we'll be using the Cloud Pak for Applications platform to create Cloud Native Applications that run on OpenShift. The goals of this workshop are: Use Appsody and Codewind to create a cloud native application Create a custom Collection Use Tekton CI to continuously deploy to OpenShift","title":"Creating Cloud Native Applications with Cloud Pak for Applications on OpenShift"},{"location":"#about-this-workshop","text":"The introductory page of the workshop is broken down into the following sections: Agenda Compatability About Cloud Pak for Applications Credits","title":"About this workshop"},{"location":"#agenda","text":"","title":"Agenda"},{"location":"#day-1-kabanero-and-appsody-for-developers-and-operators","text":"In this first day we'll learn how to use Appsody to run the inner loop of the development and test cycle for a developer, and how these tools can be integrated into your favorite IDE. We'll also explore how to deploy an application to OpenShift, first manually with Appsody for dev/test purposes, and then using the standard Kabanero Tekton piplines with GitOps as part of a continual test/production cycle. Lecture 1: What is Cloud Native? Learn about the technologies that underpin Cloud Native applications Lecture 2: Kabanero Overview Learn about Kabanero. An open source project to rapidly create Cloud Native applications Exercise 1: Introduction to Appsody and Codewind Install the Appsody component of Kabanero into the IDE with Codewind, Learn about the developer flow, building your first application with Appsody Exercise 2: Using Appsody CLI to develop, test, and debug applications Use the Appsody CLI to quickly create frontend and backend applications for a sample application using two different technologies (Spring and nodejs express) Exercise 3: Deploying to OpenShift with Appsody Deploy the built applications to IBM Managed OpenShift with Appsody for dev/test purposes Lecture 3: Adding value with IBM Cloud Pak for Applications Learn about how IBM Cloud Pak for Applications bundles everything together Exercise 4: Use Tekton and Kabanero Pipelines to continuously deploy Deploy the built applications to IBM Managed OpenShift using GitOps to trigger a Tekton pipeline","title":"Day 1: Kabanero and Appsody for Developers and Operators"},{"location":"#day-2-customizing-stacks-pipelines-in-collections","text":"In the second day we'll learn about the Kabanero open source project and how to productionize our applications with custom Appsody Stacks, custom Collections, and custom Tekton pipelines. Lecture 4: Customizing Appsody and Kabanero Learn all about the stacks and repos Exercise 6: Building a custom Collection Create a collection that will contain custom appsody stacks and pipelines Exercise 5: Customizing an existing Appsody Stack Create a custom stack, to be hosted in our custom repository Exercise 7: Using a custom Collection with Appsody Learn how to manage these custom stacks and how to make them available to developers Lecture 5: Tekton Overview Learn all Tekton CI/CD and how Kabanero uses it Exercise 8: Create a custom Tekton Task and Pipleline Build a pipeline that will fit into a custom Collection Exercise 9: Deploy an application with a custom Stack, custom Collection, and custom Pipeline Build and deploy an application using the custom stack, collection and pipelines built by the Architects' and Operators' tracks","title":"Day 2: Customizing Stacks, Pipelines in Collections"},{"location":"#compatability","text":"This workshop has been tested on the following platforms: macOS : Mojave (10.14), Catalina (10.15) Windows Windows 10 (with enterprise AAD and git bash)","title":"Compatability"},{"location":"#about-cloud-pak-for-applications","text":"IBM Cloud Pak for Applications is an enterprise-ready, containerized software solution for modernizing existing applications and developing new cloud-native apps that run on Red Hat\u00ae OpenShift\u00ae. Built on IBM WebSphere offerings and Red Hat OpenShift Container Platform with the Kabanero open source project, Cloud Pak for Applications provides a long-term solution to help you transition between public, private, and hybrid clouds, and create new business applications.","title":"About Cloud Pak for Applications"},{"location":"#a-few-other-noteworthy-mentions","text":"Cloud Pak for Applications: ... includes the Kabanero open source project WebSphere Mobile Foundation IBM Cloud Private Transformation Advisory ...and more ... can be deployed on any major cloud provider supporting OpenShift (IBM Cloud, AWS, Azure, GCP)","title":"A few other noteworthy mentions"},{"location":"#credits","text":"This workshop was primarily written by Henry Nash and Steve Martinelli . Many other IBMers have contributed to help shape, test, and contribute to the workshop. Greg Dritschler : For his Insurance Quote Code Pattern Carlos Santana : For his Learning Kabanero 101 Tutorial Tim Robinson : For testing the lab on Windows","title":"Credits"},{"location":"about-day-1/","text":"Workshop Day 1 \u00b6 Day 1: Kabanero and Appsody for Developers and Operators \u00b6 In this first day we'll learn how to use Appsody to run the inner loop of the development and test cycle for a developer, and how these tools can be integrated into your favorite IDE. We'll also explore how to deploy an application to OpenShift, first manually with Appsody for dev/test purposes, and then using the standard Kabanero Tekton piplines with GitOps as part of a continual test/production cycle. Our goal for the end of the day is represented below. But, don't worry about it right now, we'll get there together by following the exercises step-by-step. Agenda \u00b6 Section Description Lecture 1: What is Cloud Native? Learn about the technologies that underpin Cloud Native applications Lecture 2: Kabanero Overview Learn about Kabanero. An open source project to rapidly create Cloud Native applications Exercise 1: Introduction to Appsody and Codewind Install the Appsody component of Kabanero into the IDE with Codewind, Learn about the developer flow, building your first application with Appsody Exercise 2: Using Appsody CLI to develop, test, and debug applications Use the Appsody CLI to quickly create frontend and backend applications for a sample application using two different technologies (Spring and nodejs express) Exercise 3: Deploying to OpenShift with Appsody Deploy the built applications to IBM Managed OpenShift with Appsody for dev/test purposes Lecture 3: Adding value with IBM Cloud Pak for Applications Learn about how IBM Cloud Pak for Applications bundles everything together Exercise 4: Use Tekton and Kabanero Pipelines to continuously deploy Deploy the built applications to IBM Managed OpenShift using GitOps to trigger a Tekton pipeline","title":"About Day 1"},{"location":"about-day-1/#workshop-day-1","text":"","title":"Workshop Day 1"},{"location":"about-day-1/#day-1-kabanero-and-appsody-for-developers-and-operators","text":"In this first day we'll learn how to use Appsody to run the inner loop of the development and test cycle for a developer, and how these tools can be integrated into your favorite IDE. We'll also explore how to deploy an application to OpenShift, first manually with Appsody for dev/test purposes, and then using the standard Kabanero Tekton piplines with GitOps as part of a continual test/production cycle. Our goal for the end of the day is represented below. But, don't worry about it right now, we'll get there together by following the exercises step-by-step.","title":"Day 1: Kabanero and Appsody for Developers and Operators"},{"location":"about-day-1/#agenda","text":"Section Description Lecture 1: What is Cloud Native? Learn about the technologies that underpin Cloud Native applications Lecture 2: Kabanero Overview Learn about Kabanero. An open source project to rapidly create Cloud Native applications Exercise 1: Introduction to Appsody and Codewind Install the Appsody component of Kabanero into the IDE with Codewind, Learn about the developer flow, building your first application with Appsody Exercise 2: Using Appsody CLI to develop, test, and debug applications Use the Appsody CLI to quickly create frontend and backend applications for a sample application using two different technologies (Spring and nodejs express) Exercise 3: Deploying to OpenShift with Appsody Deploy the built applications to IBM Managed OpenShift with Appsody for dev/test purposes Lecture 3: Adding value with IBM Cloud Pak for Applications Learn about how IBM Cloud Pak for Applications bundles everything together Exercise 4: Use Tekton and Kabanero Pipelines to continuously deploy Deploy the built applications to IBM Managed OpenShift using GitOps to trigger a Tekton pipeline","title":"Agenda"},{"location":"about-day-2/","text":"Workshop Day 2 \u00b6 Day 2: Customizing Stacks, Pipelines in Collections \u00b6 In the second day we'll learn about the Kabanero open source project and how to productionize our applications with custom Appsody Stacks, custom Collections, and custom Tekton pipelines. Section Description Lecture 4: Customizing Appsody and Kabanero Learn about the stacks and repos Exercise 5: Customizing an existing Appsody Stack Create a custom stack, to be hosted in our custom repository Exercise 6: Building a custom Collection Create a collection that will contain custom appsody stacks and pipelines Exercise 7: Using a custom Collection with Appsody Test the developer experience with the custom appsody stack in the collection Lecture 5: Tekton Overview Learn about Tekton CI/CD and how Kabanero uses it Exercise 8: Create a custom Tekton Task and Pipleline Build a pipeline that will fit into a custom Collection Exercise 9: Deploy an application with a custom Stack, custom Collection, and custom Pipeline Build and deploy an application using the custom stack, collection and pipelines built by the Architects' and Operators' tracks","title":"About Day 2"},{"location":"about-day-2/#workshop-day-2","text":"","title":"Workshop Day 2"},{"location":"about-day-2/#day-2-customizing-stacks-pipelines-in-collections","text":"In the second day we'll learn about the Kabanero open source project and how to productionize our applications with custom Appsody Stacks, custom Collections, and custom Tekton pipelines. Section Description Lecture 4: Customizing Appsody and Kabanero Learn about the stacks and repos Exercise 5: Customizing an existing Appsody Stack Create a custom stack, to be hosted in our custom repository Exercise 6: Building a custom Collection Create a collection that will contain custom appsody stacks and pipelines Exercise 7: Using a custom Collection with Appsody Test the developer experience with the custom appsody stack in the collection Lecture 5: Tekton Overview Learn about Tekton CI/CD and how Kabanero uses it Exercise 8: Create a custom Tekton Task and Pipleline Build a pipeline that will fit into a custom Collection Exercise 9: Deploy an application with a custom Stack, custom Collection, and custom Pipeline Build and deploy an application using the custom stack, collection and pipelines built by the Architects' and Operators' tracks","title":"Day 2: Customizing Stacks, Pipelines in Collections"},{"location":"exercise-1/","text":"Exercise 1: Introduction to Appsody and Codewind \u00b6 In this exercise, we will introduce Appsody, which is the underpinning development flow in Kabanero, along with its integration into IDEs using Codewind. In particular you will become experienced with: the components of the Appsody development toolbox the concept of pre-configured \"stacks\" and templates for popular open source runtimes (such as Node.js and Spring Boot) on which to build applications the Appsody command-line interface to develop containerized applications, how to run and test them locally, Prerequisites \u00b6 You should have already carried out the prerequisites defined in the Pre-work . Check that you have access to the Appsody CLI by typing (the exact version number my be greater than shown below): NOTE: In the exercises that follow you will see the actual command to run, followed by a separate example of running the command with the expected output. You only need to run the first example and never need to run a command you see preceded by a \"$\". You can even use the copy button on the right side of the command to make copying easier. appsody version You should see output similar to the following: $ appsody version appsody 0 .5.3 Steps \u00b6 Configure Appsody CLI Use Appsody CLI to build, test, run, and debug Appsody tasks on VS Code Codewind on VS Code 1. Configure Appsody CLI \u00b6 In this section we'll configure our Appsody CLI to pull in Collections. List existing Appsody stacks \u00b6 The Appsody CLI gives you access to stacks, which are stored in stack repositories. These can be local, private to the Enterprise or public. To get the list of available repos, run this command. appsody repo list You should see output similar to the following: $ appsody repo list NAME URL *incubator https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml The exact repo list may be different to the above. incubator is one of the repos in the appsody project public hub ( appsodyhub ). For this workshop we are going to use the private enterprise-grade collection of stacks that come with the Kabanero open source project (which is part of Cloud Pak for Applications). So the first thing we need to do is to tell the CLI about this. Add Collection to Appsody \u00b6 From the Cloud Pak for Applications landing page get the CollectionHub URL, for example: https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml Use the appsody CLI to add the Collection repo. appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/0.2.1/kabanero-index.yaml Now when we get our list of repos, we should see Kabanero listed: appsody repo list You should see output similar to the following: $ appsody repo list NAME URL *incubator https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml kabanero https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml We can now list the appsody stacks available in the Collection: appsody list kabanero You should see output similar to the following: $ appsody list kabanero REPO ID VERSION TEMPLATES DESCRIPTION kabanero java-microprofile 0 .2.11 *default Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven kabanero java-spring-boot2 0 .3.9 *default, kotlin Spring Boot using OpenJ9 and Maven kabanero nodejs 0 .2.5 *simple Runtime for Node.js applications kabanero nodejs-express 0 .2.5 *simple, skaffold Express web framework for Node.js kabanero nodejs-loopback 0 .1.4 *scaffold LoopBack 4 API Framework for Node.js Given that we'll exclusively be using the kabanero stacks in this workshop, for ease of use we can set the kabanero repository to be the default for the CLI: appsody repo set-default kabanero Now is we get the list of repos, we should see kabanero is the default: appsody repo list You should see output similar to the following: $ appsody repo list NAME URL *kabanero https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml incubator https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml 2. Use Appsody CLI to build, test, run, and debug \u00b6 In this section we'll be using the following appsody commands: appsody init appsody run appsody test appsody debug appsody build Create a new directory to work with new applications \u00b6 We recommend creating a new directory from your user home to work with new Appsody based applications, i.e.: cd ~ mkdir appsody-apps cd appsody-apps Create a new application \u00b6 We will now use one of the stacks to create an application. First, create a new directory for the project and change directory into it. mkdir appsody_sample_nodejs-express cd appsody_sample_nodejs-express/ Initialize the project using appsody init : appsody init kabanero/nodejs-express The directory has been initialized with a minimal set of artifacts (which is, in fact, a sample application that uses the chosen stack) . \u251c\u2500\u2500 .appsody-config.yaml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 .vscode \u2502 \u251c\u2500\u2500 launch.json \u2502 \u2514\u2500\u2500 tasks.json \u251c\u2500\u2500 app.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u2514\u2500\u2500 test \u2514\u2500\u2500 test.js The key artifacts are: app.js Node.js application module (the default sample application is a simple \"hello world\") package.json NPM package JSON file test.js A simple test module Run the application \u00b6 The sample application comes ready to run using appsody: appsody run This step results in the stack image, with the sample application mounted into it, run in your local Docker environment. The output finishes by giving you the endpoint for the application. Running development environment... Running command: docker pull kabanero/nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 8080 :8080 -p 9229 :9229 --name appsody-sample-nodejs-express-dev -v /Users/csantanapr/dev/kabanero/appsody_sample_nodejs-express/:/project/user-app -v appsody-sample-nodejs-express-deps:/project/user-app/node_modules -v /Users/csantanapr/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller kabanero/nodejs-express:0.2 --mode = run [ Container ] Running APPSODY_PREP command: npm install --prefix user-app audited 295 packages in 1 .546s [ Container ] found 0 vulnerabilities [ Container ] [ Container ] Running command: npm start [ Container ] [ Container ] > nodejs-express@0.2.6 start /project [ Container ] > node server.js [ Container ] [ Container ] [ Sun Sep 22 23 :29:50 2019 ] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5 .0.5.201909191743 ( Agent Core 4 .0.5 ) [ Container ] [ Sun Sep 22 23 :29:51 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 [ Container ] App started on PORT 3000 We can now check that this is running by hitting the endpoint http://localhost:3000 : curl http://localhost:3000 You should see output similar to the following: $ curl http://localhost:3000 Hello from Appsody! By default, the template sample application also provides the following endpoints. Readiness endpoint: http://localhost:3000/ready Liveness endpoint: http://localhost:3000/live Health check endpoint: http://localhost:3000/health Metrics endpoint: http://localhost:3000/metrics For more details on this particular stack, refer to Node.js Express Stack . Stop the application \u00b6 To stop the application container, run this command from the same directory (e.g. in another terminal window): appsody stop Test the application \u00b6 A stack will typically come with a test framework - and this can be initiated by running: appsody test You should see output similar to the following: $ appsody test Running test environment Running command: docker pull kabanero/nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 8080 :8080 -p 9229 :9229 --name appsody-sample-nodejs-express-dev -v /Users/csantanapr/dev/kabanero/appsody_sample_nodejs-express/:/project/user-app -v appsody-sample-nodejs-express-deps:/project/user-app/node_modules -v /Users/csantanapr/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller kabanero/nodejs-express:0.2 --mode = test [ Container ] Running APPSODY_PREP command: npm install --prefix user-app added 170 packages from 578 contributors and audited 295 packages in 2 .76s ... [ Container ] Running command: npm test && npm test --prefix user-app [ Container ] [ Container ] > nodejs-express@0.2.6 test /project [ Container ] > mocha ... [ Container ] App started on PORT 3000 ... [ Container ] [ Container ] 7 passing ( 44ms ) [ Container ] [ Container ] [ Container ] > nodejs-express-simple@0.1.0 test /project/user-app [ Container ] > mocha [ Container ] ... [ Container ] App started on PORT 3000 [ Container ] Node.js Express Simple template [ Container ] / endpoint [ Container ] \u2713 status [ Container ] [ Container ] [ Container ] 1 passing ( 40ms ) [ Container ] [ Container ] The file watcher is not running because no APPSODY_RUN/TEST/DEBUG_ON_CHANGE action was specified or it has been disabled using the --no-watcher flag. Debug the application \u00b6 As well as supporting the running and testing of your application, an appsody stack enables the execution of your application in debug mode. Typically the stack will be configured to support whatever the appropriate debugger is for the language and technology components within it. Open an IDE for debugging the application. The examples here will be based on VS Code. After starting the IDE add the project to your workspace or launch VS Code using code from the application directory.` Open a new terminal window inside VS Code use View -> Terminal To debug the application including reloading the application on code changes run the below command: appsody debug The output indicates the debug environment is being used Running debug environment Running command: docker pull kabanero/nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 8080 :8080 -p 9229 :9229 --name appsody-sample-nodejs-express-dev -v /Users/csantana23/dev/kabanero/appsody_sample_nodejs-express/:/project/user-app -v appsody-sample-nodejs-express-deps:/project/user-app/node_modules -v /Users/csantana23/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller kabanero/nodejs-express:0.2 --mode = debug [ Container ] Running APPSODY_PREP command: npm install --prefix user-app audited 295 packages in 1 .154s [ Container ] found 0 vulnerabilities [ Container ] [ Container ] Running command: npm run debug [ Container ] [ Container ] > nodejs-express@0.2.6 debug /project [ Container ] > node --inspect = 0 .0.0.0 server.js [ Container ] [ Container ] Debugger listening on ws://0.0.0.0:9229/35c7d2cb-ced9-4c57-94f1-a58a5e078302 [ Container ] For help, see: https://nodejs.org/en/docs/inspector [ Container ] [ Sun Sep 22 23 :38:35 2019 ] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5 .0.5.201909191743 ( Agent Core 4 .0.5 ) [ Container ] [ Sun Sep 22 23 :38:35 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 [ Container ] App started on PORT 3000 Now you can again open the application at http://localhost:3000/ Make an update to the application by opening the app.js file and editing the message. Then save the file. Appsody will now rebuild the container and reload the application for you. Refresh the browser to see the changes: You can attach to the Node.js debugger using VS Code. To access the debug view use View -> Debug or click Debug icon on left menu: Add a breakpoint to the application, click to the left of the line number: Click on the debug task Appsody: Attach node and click the Play button: Refresh the browser and watch how the debugger stops at the breakpoint: Stop the VS Code debugging session (by pressing the red stop/disconnect icon). From the application directory, stop the appsody debug session by entering appsody stop in a terminal window. Build the application \u00b6 Up until now, we have been using appsody in what we call \"Rapid Local Development Mode\", where we can cycle through code change, test and debug - all within a local Docker environment. Appsody is making this environment possible, through a combination of the CLI, the stack and appsody code within that stack. Once you are ready to deploy the application outside of appsody control, there are two additional appsody commands to help you. These enable a couple of capabilities: support for building a standalone docker image (containing your application and the stack technologies), that can be deployed either using regular Docker commands, or manually to a kubernetes cluster. support deploying the final image directly to a kubernetes cluster, under control of the Appsody Operator. We will cover deployment in Exercise 3 . In this section we will carry out the first of these - i.e. simply building a standalone image. Perhaps unsurprisingly, this is enacted by: appsody build You should see output similar to the following: $ appsody build . . . [ Docker ] Removing intermediate container 264b4dd86f2c [ Docker ] ---> 3a7e5ca613f2 [ Docker ] Step 20 /21 : EXPOSE 3000 [ Docker ] ---> Running in fb7b734205a8 [ Docker ] Removing intermediate container fb7b734205a8 [ Docker ] ---> badce710593d [ Docker ] Step 21 /21 : CMD [ \"npm\" , \"start\" ] [ Docker ] ---> Running in 961a344e2c68 [ Docker ] Removing intermediate container 961a344e2c68 [ Docker ] ---> e417d7dfc54c [ Docker ] Successfully built e417d7dfc54c [ Docker ] Successfully tagged appsody-sample-nodejs-express:latest Built docker image appsody-sample-nodejs-express We now have a standalone image (independent of appsody). We can view the image using our local Docker environment: docker images You should see output similar to the following: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE appsody-sample-nodejs-express latest 0be125eee32c 3 minutes ago 945MB We can run this with our local Docker environment in the normal way (making sure we map the exposed port): docker run -p 3000 :3000 appsody-sample-nodejs-express You should see output similar to the following: $ docker run -p 3000 :3000 appsody-sample-nodejs-express ... > nodejs-express@0.2.6 start /project > node server.js ... [ Tue Oct 1 19 :49:45 2019 ] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5 .0.5.201910011945 ( Agent Core 4 .0.5 ) [ Tue Oct 1 19 :49:46 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 App started on PORT 3000 Again, hitting the endpoint of http://localhost:3000/ should give us the hello message. You now have seen the basics of the appsody CLI in operation. We'll now take things up a level, and see how the CLI can be integrated into an IDE (VS Code in this case). Before we do this, terminate the current docker run using Ctrl-C. 3. Appsody tasks on VS Code \u00b6 To access the build tasks on VS code, go to: Terminal > Run Build Task ... You will see a list of available tasks: Click on Appsody: run and this will run the application: Once it is successfully started, you can, again, access the application at http://localhost:3000/ : You can also run the Appsody: stop task: 4. Codewind on VS Code \u00b6 Codewind simplifies and enhances development in containers by extending industry-standard IDEs with features to write, debug, and deploy cloud-native applications. It helps you to get started quickly with templates or samples, or you can also pull in your applications and let Codewind get them cloud-ready. Codewind supports VS Code, Eclipse Che, and Eclipse. In this lab, we are using VS Code as our IDE. Getting the Codewind extension \u00b6 To get codewind extension you need VS Code version 1.28 or later . Go to the extensions view and search for Codewind from the VS Code marketplace: You will find Codewind then click install to get it. Also, if you want to use Codewind for Node.js performance analysis, you need to install Codewind Node.js Profiler . Once installed, in VS Code, go to View > Open View ... It gives you you a list of options. Select Codewind : This opens Codewind : Adding the application \u00b6 You can create a new project or add an existing project to Codewind. Since, we already created one using appsody earlier, we can add the existing project. In order to do this, we must first copy the project to the codewind workspace (which is codewind-workspaces/ in your HOME directory on macOS, or typically C:\\codewind-workspace on Windows). For example, on macOS: cd ~ cp -R appsody-apps/appsody_sample_nodejs-express codewind-workspaces To add the project, right click (or Ctrl-click) on Projects under Codewind. Select Add Existing Project in the menu: From the codewind workspace, select the project you created earlier: The codewind extension asks you for confirmation as follows. Click Yes . The project will be added. Once it is successfully built, it starts running: You can open the CodeWind workspace, right click on Projects : Project options \u00b6 Go to the application and right click on it to access the various options available: Click Open App to access the application: NOTE Codewind exposes your applications on different external ports. This will allow you to run multiple projects of same type. To get the overview of your project, click on Open Project Overview : You can access the container shell directly from the IDE by using Open Container Shell : To access the logs of the application, click on Show all logs : You can also hide the logs if you want to by using Hide all logs option: If you have multiple applications and want to manage the logs for them, you can use Manage logs : You can also run the application by using Restart in Run Mode : Once it is restarted, you can access the application by clicking on the button as shown below: Similarly, you can also do debugging by using Restart in Debug Mode . Application Performance, Monitor, Profiling with Codewind \u00b6 You can launch the app monitor by selecting Open Appplication Monitor : The monitor dashboard will open in the browser: You can launch the app performance dashboard by selecting Open Performance Dashboard : The performance dashboard will open in the browser: You can click Run Test and have Monitor and Performance dashboards side by side during the test: NOTE: Profiling the node.js code is currently not working, an issue is opened on the github repo for the codewind node.js profiler extension. Congratulations ! You've just completed the intro exercises for Appsody and Codewind!","title":"Lab 1. Intro to Appsody and Codewind"},{"location":"exercise-1/#exercise-1-introduction-to-appsody-and-codewind","text":"In this exercise, we will introduce Appsody, which is the underpinning development flow in Kabanero, along with its integration into IDEs using Codewind. In particular you will become experienced with: the components of the Appsody development toolbox the concept of pre-configured \"stacks\" and templates for popular open source runtimes (such as Node.js and Spring Boot) on which to build applications the Appsody command-line interface to develop containerized applications, how to run and test them locally,","title":"Exercise 1: Introduction to Appsody and Codewind"},{"location":"exercise-1/#prerequisites","text":"You should have already carried out the prerequisites defined in the Pre-work . Check that you have access to the Appsody CLI by typing (the exact version number my be greater than shown below): NOTE: In the exercises that follow you will see the actual command to run, followed by a separate example of running the command with the expected output. You only need to run the first example and never need to run a command you see preceded by a \"$\". You can even use the copy button on the right side of the command to make copying easier. appsody version You should see output similar to the following: $ appsody version appsody 0 .5.3","title":"Prerequisites"},{"location":"exercise-1/#steps","text":"Configure Appsody CLI Use Appsody CLI to build, test, run, and debug Appsody tasks on VS Code Codewind on VS Code","title":"Steps"},{"location":"exercise-1/#1-configure-appsody-cli","text":"In this section we'll configure our Appsody CLI to pull in Collections.","title":"1. Configure Appsody CLI"},{"location":"exercise-1/#list-existing-appsody-stacks","text":"The Appsody CLI gives you access to stacks, which are stored in stack repositories. These can be local, private to the Enterprise or public. To get the list of available repos, run this command. appsody repo list You should see output similar to the following: $ appsody repo list NAME URL *incubator https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml The exact repo list may be different to the above. incubator is one of the repos in the appsody project public hub ( appsodyhub ). For this workshop we are going to use the private enterprise-grade collection of stacks that come with the Kabanero open source project (which is part of Cloud Pak for Applications). So the first thing we need to do is to tell the CLI about this.","title":"List existing Appsody stacks"},{"location":"exercise-1/#add-collection-to-appsody","text":"From the Cloud Pak for Applications landing page get the CollectionHub URL, for example: https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml Use the appsody CLI to add the Collection repo. appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/0.2.1/kabanero-index.yaml Now when we get our list of repos, we should see Kabanero listed: appsody repo list You should see output similar to the following: $ appsody repo list NAME URL *incubator https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml kabanero https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml We can now list the appsody stacks available in the Collection: appsody list kabanero You should see output similar to the following: $ appsody list kabanero REPO ID VERSION TEMPLATES DESCRIPTION kabanero java-microprofile 0 .2.11 *default Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven kabanero java-spring-boot2 0 .3.9 *default, kotlin Spring Boot using OpenJ9 and Maven kabanero nodejs 0 .2.5 *simple Runtime for Node.js applications kabanero nodejs-express 0 .2.5 *simple, skaffold Express web framework for Node.js kabanero nodejs-loopback 0 .1.4 *scaffold LoopBack 4 API Framework for Node.js Given that we'll exclusively be using the kabanero stacks in this workshop, for ease of use we can set the kabanero repository to be the default for the CLI: appsody repo set-default kabanero Now is we get the list of repos, we should see kabanero is the default: appsody repo list You should see output similar to the following: $ appsody repo list NAME URL *kabanero https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml incubator https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml","title":"Add Collection to Appsody"},{"location":"exercise-1/#2-use-appsody-cli-to-build-test-run-and-debug","text":"In this section we'll be using the following appsody commands: appsody init appsody run appsody test appsody debug appsody build","title":"2. Use Appsody CLI to build, test, run, and debug"},{"location":"exercise-1/#create-a-new-directory-to-work-with-new-applications","text":"We recommend creating a new directory from your user home to work with new Appsody based applications, i.e.: cd ~ mkdir appsody-apps cd appsody-apps","title":"Create a new directory to work with new applications"},{"location":"exercise-1/#create-a-new-application","text":"We will now use one of the stacks to create an application. First, create a new directory for the project and change directory into it. mkdir appsody_sample_nodejs-express cd appsody_sample_nodejs-express/ Initialize the project using appsody init : appsody init kabanero/nodejs-express The directory has been initialized with a minimal set of artifacts (which is, in fact, a sample application that uses the chosen stack) . \u251c\u2500\u2500 .appsody-config.yaml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 .vscode \u2502 \u251c\u2500\u2500 launch.json \u2502 \u2514\u2500\u2500 tasks.json \u251c\u2500\u2500 app.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u2514\u2500\u2500 test \u2514\u2500\u2500 test.js The key artifacts are: app.js Node.js application module (the default sample application is a simple \"hello world\") package.json NPM package JSON file test.js A simple test module","title":"Create a new application"},{"location":"exercise-1/#run-the-application","text":"The sample application comes ready to run using appsody: appsody run This step results in the stack image, with the sample application mounted into it, run in your local Docker environment. The output finishes by giving you the endpoint for the application. Running development environment... Running command: docker pull kabanero/nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 8080 :8080 -p 9229 :9229 --name appsody-sample-nodejs-express-dev -v /Users/csantanapr/dev/kabanero/appsody_sample_nodejs-express/:/project/user-app -v appsody-sample-nodejs-express-deps:/project/user-app/node_modules -v /Users/csantanapr/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller kabanero/nodejs-express:0.2 --mode = run [ Container ] Running APPSODY_PREP command: npm install --prefix user-app audited 295 packages in 1 .546s [ Container ] found 0 vulnerabilities [ Container ] [ Container ] Running command: npm start [ Container ] [ Container ] > nodejs-express@0.2.6 start /project [ Container ] > node server.js [ Container ] [ Container ] [ Sun Sep 22 23 :29:50 2019 ] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5 .0.5.201909191743 ( Agent Core 4 .0.5 ) [ Container ] [ Sun Sep 22 23 :29:51 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 [ Container ] App started on PORT 3000 We can now check that this is running by hitting the endpoint http://localhost:3000 : curl http://localhost:3000 You should see output similar to the following: $ curl http://localhost:3000 Hello from Appsody! By default, the template sample application also provides the following endpoints. Readiness endpoint: http://localhost:3000/ready Liveness endpoint: http://localhost:3000/live Health check endpoint: http://localhost:3000/health Metrics endpoint: http://localhost:3000/metrics For more details on this particular stack, refer to Node.js Express Stack .","title":"Run the application"},{"location":"exercise-1/#stop-the-application","text":"To stop the application container, run this command from the same directory (e.g. in another terminal window): appsody stop","title":"Stop the application"},{"location":"exercise-1/#test-the-application","text":"A stack will typically come with a test framework - and this can be initiated by running: appsody test You should see output similar to the following: $ appsody test Running test environment Running command: docker pull kabanero/nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 8080 :8080 -p 9229 :9229 --name appsody-sample-nodejs-express-dev -v /Users/csantanapr/dev/kabanero/appsody_sample_nodejs-express/:/project/user-app -v appsody-sample-nodejs-express-deps:/project/user-app/node_modules -v /Users/csantanapr/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller kabanero/nodejs-express:0.2 --mode = test [ Container ] Running APPSODY_PREP command: npm install --prefix user-app added 170 packages from 578 contributors and audited 295 packages in 2 .76s ... [ Container ] Running command: npm test && npm test --prefix user-app [ Container ] [ Container ] > nodejs-express@0.2.6 test /project [ Container ] > mocha ... [ Container ] App started on PORT 3000 ... [ Container ] [ Container ] 7 passing ( 44ms ) [ Container ] [ Container ] [ Container ] > nodejs-express-simple@0.1.0 test /project/user-app [ Container ] > mocha [ Container ] ... [ Container ] App started on PORT 3000 [ Container ] Node.js Express Simple template [ Container ] / endpoint [ Container ] \u2713 status [ Container ] [ Container ] [ Container ] 1 passing ( 40ms ) [ Container ] [ Container ] The file watcher is not running because no APPSODY_RUN/TEST/DEBUG_ON_CHANGE action was specified or it has been disabled using the --no-watcher flag.","title":"Test the application"},{"location":"exercise-1/#debug-the-application","text":"As well as supporting the running and testing of your application, an appsody stack enables the execution of your application in debug mode. Typically the stack will be configured to support whatever the appropriate debugger is for the language and technology components within it. Open an IDE for debugging the application. The examples here will be based on VS Code. After starting the IDE add the project to your workspace or launch VS Code using code from the application directory.` Open a new terminal window inside VS Code use View -> Terminal To debug the application including reloading the application on code changes run the below command: appsody debug The output indicates the debug environment is being used Running debug environment Running command: docker pull kabanero/nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 8080 :8080 -p 9229 :9229 --name appsody-sample-nodejs-express-dev -v /Users/csantana23/dev/kabanero/appsody_sample_nodejs-express/:/project/user-app -v appsody-sample-nodejs-express-deps:/project/user-app/node_modules -v /Users/csantana23/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller kabanero/nodejs-express:0.2 --mode = debug [ Container ] Running APPSODY_PREP command: npm install --prefix user-app audited 295 packages in 1 .154s [ Container ] found 0 vulnerabilities [ Container ] [ Container ] Running command: npm run debug [ Container ] [ Container ] > nodejs-express@0.2.6 debug /project [ Container ] > node --inspect = 0 .0.0.0 server.js [ Container ] [ Container ] Debugger listening on ws://0.0.0.0:9229/35c7d2cb-ced9-4c57-94f1-a58a5e078302 [ Container ] For help, see: https://nodejs.org/en/docs/inspector [ Container ] [ Sun Sep 22 23 :38:35 2019 ] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5 .0.5.201909191743 ( Agent Core 4 .0.5 ) [ Container ] [ Sun Sep 22 23 :38:35 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 [ Container ] App started on PORT 3000 Now you can again open the application at http://localhost:3000/ Make an update to the application by opening the app.js file and editing the message. Then save the file. Appsody will now rebuild the container and reload the application for you. Refresh the browser to see the changes: You can attach to the Node.js debugger using VS Code. To access the debug view use View -> Debug or click Debug icon on left menu: Add a breakpoint to the application, click to the left of the line number: Click on the debug task Appsody: Attach node and click the Play button: Refresh the browser and watch how the debugger stops at the breakpoint: Stop the VS Code debugging session (by pressing the red stop/disconnect icon). From the application directory, stop the appsody debug session by entering appsody stop in a terminal window.","title":"Debug the application"},{"location":"exercise-1/#build-the-application","text":"Up until now, we have been using appsody in what we call \"Rapid Local Development Mode\", where we can cycle through code change, test and debug - all within a local Docker environment. Appsody is making this environment possible, through a combination of the CLI, the stack and appsody code within that stack. Once you are ready to deploy the application outside of appsody control, there are two additional appsody commands to help you. These enable a couple of capabilities: support for building a standalone docker image (containing your application and the stack technologies), that can be deployed either using regular Docker commands, or manually to a kubernetes cluster. support deploying the final image directly to a kubernetes cluster, under control of the Appsody Operator. We will cover deployment in Exercise 3 . In this section we will carry out the first of these - i.e. simply building a standalone image. Perhaps unsurprisingly, this is enacted by: appsody build You should see output similar to the following: $ appsody build . . . [ Docker ] Removing intermediate container 264b4dd86f2c [ Docker ] ---> 3a7e5ca613f2 [ Docker ] Step 20 /21 : EXPOSE 3000 [ Docker ] ---> Running in fb7b734205a8 [ Docker ] Removing intermediate container fb7b734205a8 [ Docker ] ---> badce710593d [ Docker ] Step 21 /21 : CMD [ \"npm\" , \"start\" ] [ Docker ] ---> Running in 961a344e2c68 [ Docker ] Removing intermediate container 961a344e2c68 [ Docker ] ---> e417d7dfc54c [ Docker ] Successfully built e417d7dfc54c [ Docker ] Successfully tagged appsody-sample-nodejs-express:latest Built docker image appsody-sample-nodejs-express We now have a standalone image (independent of appsody). We can view the image using our local Docker environment: docker images You should see output similar to the following: $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE appsody-sample-nodejs-express latest 0be125eee32c 3 minutes ago 945MB We can run this with our local Docker environment in the normal way (making sure we map the exposed port): docker run -p 3000 :3000 appsody-sample-nodejs-express You should see output similar to the following: $ docker run -p 3000 :3000 appsody-sample-nodejs-express ... > nodejs-express@0.2.6 start /project > node server.js ... [ Tue Oct 1 19 :49:45 2019 ] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5 .0.5.201910011945 ( Agent Core 4 .0.5 ) [ Tue Oct 1 19 :49:46 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 App started on PORT 3000 Again, hitting the endpoint of http://localhost:3000/ should give us the hello message. You now have seen the basics of the appsody CLI in operation. We'll now take things up a level, and see how the CLI can be integrated into an IDE (VS Code in this case). Before we do this, terminate the current docker run using Ctrl-C.","title":"Build the application"},{"location":"exercise-1/#3-appsody-tasks-on-vs-code","text":"To access the build tasks on VS code, go to: Terminal > Run Build Task ... You will see a list of available tasks: Click on Appsody: run and this will run the application: Once it is successfully started, you can, again, access the application at http://localhost:3000/ : You can also run the Appsody: stop task:","title":"3. Appsody tasks on VS Code"},{"location":"exercise-1/#4-codewind-on-vs-code","text":"Codewind simplifies and enhances development in containers by extending industry-standard IDEs with features to write, debug, and deploy cloud-native applications. It helps you to get started quickly with templates or samples, or you can also pull in your applications and let Codewind get them cloud-ready. Codewind supports VS Code, Eclipse Che, and Eclipse. In this lab, we are using VS Code as our IDE.","title":"4. Codewind on VS Code"},{"location":"exercise-1/#getting-the-codewind-extension","text":"To get codewind extension you need VS Code version 1.28 or later . Go to the extensions view and search for Codewind from the VS Code marketplace: You will find Codewind then click install to get it. Also, if you want to use Codewind for Node.js performance analysis, you need to install Codewind Node.js Profiler . Once installed, in VS Code, go to View > Open View ... It gives you you a list of options. Select Codewind : This opens Codewind :","title":"Getting the Codewind extension"},{"location":"exercise-1/#adding-the-application","text":"You can create a new project or add an existing project to Codewind. Since, we already created one using appsody earlier, we can add the existing project. In order to do this, we must first copy the project to the codewind workspace (which is codewind-workspaces/ in your HOME directory on macOS, or typically C:\\codewind-workspace on Windows). For example, on macOS: cd ~ cp -R appsody-apps/appsody_sample_nodejs-express codewind-workspaces To add the project, right click (or Ctrl-click) on Projects under Codewind. Select Add Existing Project in the menu: From the codewind workspace, select the project you created earlier: The codewind extension asks you for confirmation as follows. Click Yes . The project will be added. Once it is successfully built, it starts running: You can open the CodeWind workspace, right click on Projects :","title":"Adding the application"},{"location":"exercise-1/#project-options","text":"Go to the application and right click on it to access the various options available: Click Open App to access the application: NOTE Codewind exposes your applications on different external ports. This will allow you to run multiple projects of same type. To get the overview of your project, click on Open Project Overview : You can access the container shell directly from the IDE by using Open Container Shell : To access the logs of the application, click on Show all logs : You can also hide the logs if you want to by using Hide all logs option: If you have multiple applications and want to manage the logs for them, you can use Manage logs : You can also run the application by using Restart in Run Mode : Once it is restarted, you can access the application by clicking on the button as shown below: Similarly, you can also do debugging by using Restart in Debug Mode .","title":"Project options"},{"location":"exercise-1/#application-performance-monitor-profiling-with-codewind","text":"You can launch the app monitor by selecting Open Appplication Monitor : The monitor dashboard will open in the browser: You can launch the app performance dashboard by selecting Open Performance Dashboard : The performance dashboard will open in the browser: You can click Run Test and have Monitor and Performance dashboards side by side during the test: NOTE: Profiling the node.js code is currently not working, an issue is opened on the github repo for the codewind node.js profiler extension. Congratulations ! You've just completed the intro exercises for Appsody and Codewind!","title":"Application Performance, Monitor, Profiling with Codewind"},{"location":"exercise-2/","text":"Exercise 2: Using Appsody CLI to develop/test/debug applications \u00b6 In this exercise, we will show how to create a sample insurance quote application using Appsody. Appsody is an open source project that provides the following tools you can use to build cloud-native applications: a command-line interface to develop containerized applications, test them locally, and then build and deploy them to Kubernetes a set of pre-configured \"stacks\" and templates for popular open source runtimes (such as Node.js and Spring Boot) on which to build applications When you have completed this exercise, you will understand how to create a frontend web application and a backend REST application using the Appsody Node.js Express and Spring Boot stacks test the applications locally in a containerized environment IMPORTANT This example is used as the basis for the rest of the day 1 workshop, it's crucial to ensure it is working properly before continuing to the next exercise. Application architecture \u00b6 The user enters the URL of the frontend application into a browser. The frontend application displays an insurance quote form in response. The user fills in the form and clicks a button to submit it. The frontend application validates the form data and sends a REST request to the backend application. The backend application uses the Dacadoo Health Score API to compute a health score from the form data and then computes a quote from that. Prerequisites \u00b6 You should have already carried out the prerequisites defined in the Pre-work section. In addition to the pre-reqs above, we need to clone the repo: https://github.com/IBM/cloudpakforapps-workshop We recommend putting this repo in your user home, i.e.: cd ~ git clone https://github.com/IBM/cloudpakforapps-workshop Steps \u00b6 Create the frontend application and run it locally Create the backend application and run it locally 1. Create the frontend application and run it locally \u00b6 The frontend application is written in Node.js Express. First let's initialize an Appsody project that uses the Node.js Express stack. Create a directory somewhere outside where you cloned this project and run the appsody init command shown below. cd ~/appsody-apps mkdir quote-frontend cd quote-frontend appsody init kabanero/nodejs-express After appsody init completes, list the content of the directory. You'll see that Appsody has created a starter application for you. . \u251c\u2500\u2500 app.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u2514\u2500\u2500 test \u2514\u2500\u2500 test.js It's possible to run this application on your workstation immediately. appsody run You can see the output of the application by navigating to http://localhost:3000 in a browser window. Appsody builds a containerized version of the application for you and runs it in Docker. You can enter http://localhost:3000 in a browser to see the default endpoint served by the application. The Node.js Express stack also provides out-of-the-box health checking, application metrics endpoints and performance monitoring. In development containers (i.e. during Rapid Local Development Mode), it also provides an analysis dashboard. Health endpoint: http://localhost:3000/health Liveness endpoint: http://localhost:3000/live Readiness endpoint: http://localhost:3000/ready Metrics endpoint: http://localhost:3000/metrics Dashboard endpoint: http://localhost:3000/appmetrics-dash (development only) While the containerized application is running you can edit the application and your changes will be reflected in the running container. You can test this by editing the app.js module and changing the message returned by the default endpoint. Watch the appsody run console session for the application to restart. Then re-enter http://localhost:3000 in your browser and you will see the new message. We're going to replace the starter code with the insurance quote frontend application. First you must edit the package.json file and add the following to the dependencies section: { . . \"dependencies\" : { \"body-parser\" : \"^1.19.0\" , \"config\" : \"^3.2.0\" , \"express-validator\" : \"^6.2.0\" , \"pug\" : \"^2.0.0\" , \"request\" : \"^2.88.0\" }, . . . } The Node.js Express stack installs the package dependencies into the containerized application. However it won't do this when the containerized application is already running. You must stop the current application by entering appsody stop in a separate window, and then re-run appsody run to start it back up. Now copy the files from the quote-frontend directory in the cloned git repo to your Appsody project, for example: cp -R ~/cloudpakforapps-workshop/exercise-frontend/* . The resulting directory structure of your Appsody project should look like this: . \u2514\u2500\u2500 config \u251c\u2500\u2500 custom-environment-variables.json \u2514\u2500\u2500 development.json \u2514\u2500\u2500 test \u2514\u2500\u2500 test.js \u2514\u2500\u2500 views \u2514\u2500\u2500 quote.pug \u251c\u2500\u2500 app.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u2514\u2500\u2500 quote.js Watch for the container to restart and then refresh your browser again. You will see a form appear. You can fill in the form and hit the button to submit it and a response will appear. In this case the frontend application is not sending a request to the backend application. Instead it is configured to use a mock endpoint for testing purposes in development mode. This works as follows. quote.js uses the config module to get the value for the backend URL. When the application runs in development mode, the config module uses config/development.json to find the value for the backend URL. This file sets the URL to the mock endpoint. { \"backendUrl\" : \"http://localhost:3000/quote/test\" } When the application runs in production mode (which we'll see later), the config module uses config/custom-environment-variables.json to find the value for the backend URL. This file sets the URL from the BACKEND_URL environment variable. { \"backendUrl\" : \"BACKEND_URL\" } Press Ctrl-C in the window where the application is running to stop it. Appsody provides a way to run automated tests against the containerized application. appsody test This runs tests that come packaged with the stack (such as tests of the health and metrics endpoints), and of course you can add your own tests of your application as well. Look at tests that call GET /quote and POST /quote in test/test.js to how the frontend application is tested. 2. Create the backend application and run it locally \u00b6 The backend application is written in Spring Boot. Let's initialize an Appsody project that uses the Spring Boot 2 stack. Create a directory somewhere outside where you cloned this project and run the appsody init command shown below. cd ~/appsody-apps mkdir quote-backend cd quote-backend appsody init kabanero/java-spring-boot2 After appsody init completes, list the content of the directory. You'll see that Appsody has created a starter application for you. . \u251c\u2500\u2500 src/main/java/application/LivenessEndpoint.java \u251c\u2500\u2500 /Main.java \u251c\u2500\u2500 src/main/resources/public/index.html \u251c\u2500\u2500 /application.properties \u251c\u2500\u2500 test/java/application/MainTests.java \u251c\u2500\u2500 target/* ( compiled code ) \u251c\u2500\u2500 .appsody-config.yaml \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 pom.xml It's possible to run this application on your workstation immediately. appsody run Appsody builds a containerized version of the application for you and runs it in Docker. You can enter http://localhost:8080 in a browser to see the default endpoint served by the application. The Spring Boot 2 stack also provides out-of-the-box health checking and application metrics endpoints. Health endpoint: http://localhost:8080/actuator/health Liveness endpoint: http://localhost:8080/actuator/liveness Metrics endpoint: http://localhost:8080/actuator/metrics Prometheus endpoint: http://localhost:8080/actuator/prometheus We're going to replace the starter code with the insurance quote backend application. Edit the pom.xml file and add the following dependency to the dependencies section. <dependencies> . . . <dependency> <groupId> org.projectlombok </groupId> <artifactId> lombok </artifactId> <version> 1.18.8 </version> </dependency> </dependencies> Now copy the files from the quote-backend directory in the cloned git repo to your Appsody project, for example: cp -R ~/cloudpakforapps-workshop/exercise-backend/* . The resulting directory structure of your Appsody project should look like this: . \u251c\u2500\u2500 src/main/java/application/LivenessEndpoint.java \u251c\u2500\u2500 /Main.java \u251c\u2500\u2500 src/main/resources/public/index.html \u251c\u2500\u2500 /application.properties \u251c\u2500\u2500 /application.yaml \u251c\u2500\u2500 test/java/application/MainTests.java \u251c\u2500\u2500 test/java/application/QuoteTests.java \u251c\u2500\u2500 target/* ( compiled code ) \u251c\u2500\u2500 .appsody-config.yaml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 backend-input.json \u2514\u2500\u2500 pom.xml You can test the backend API using curl . The file backend-input.json contains sample input for the API. Issue the curl command from the project directory. curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http://localhost:8080/quote You should see output similar to the following: $ curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http://localhost:8080/quote { \"quotedAmount\" :30, \"basis\" : \"mocked backend computation\" } In this case the backend application is not sending a request to the Dacadoo health score API. Instead it is configured to use a mock endpoint for testing purposes in development mode. This works as follows: src/main/java/application/Quote.java uses @Value(\"${DACADOO_URL}\") and @Value(\"${DACADOO_APIKEY}\") to get the values of the Dacadoo Health Score API endpoint URL and the API key. src/main/resources/application.yaml defines mock values for the URL and API key. DACADOO_URL : http://localhost:8080/mockscore DACADOO_APIKEY : TEST When the application runs in production mode (which we'll see later), environment variables can be used to set the URL and API key. Environment variables override the values in the application.yaml file. Press Ctrl-C in the window where the application is running to stop it. You can use appsody test to run automated tests for this application. appsody test Look at exercise-backend/src/test/java/application/QuoteTests.java to see the tests for the backend application. Congratulations ! We have tested out our sample application locally and are ready to move on to the next step, deploying it!","title":"Lab 2. Using Appsody CLI to develop apps"},{"location":"exercise-2/#exercise-2-using-appsody-cli-to-developtestdebug-applications","text":"In this exercise, we will show how to create a sample insurance quote application using Appsody. Appsody is an open source project that provides the following tools you can use to build cloud-native applications: a command-line interface to develop containerized applications, test them locally, and then build and deploy them to Kubernetes a set of pre-configured \"stacks\" and templates for popular open source runtimes (such as Node.js and Spring Boot) on which to build applications When you have completed this exercise, you will understand how to create a frontend web application and a backend REST application using the Appsody Node.js Express and Spring Boot stacks test the applications locally in a containerized environment IMPORTANT This example is used as the basis for the rest of the day 1 workshop, it's crucial to ensure it is working properly before continuing to the next exercise.","title":"Exercise 2: Using Appsody CLI to develop/test/debug applications"},{"location":"exercise-2/#application-architecture","text":"The user enters the URL of the frontend application into a browser. The frontend application displays an insurance quote form in response. The user fills in the form and clicks a button to submit it. The frontend application validates the form data and sends a REST request to the backend application. The backend application uses the Dacadoo Health Score API to compute a health score from the form data and then computes a quote from that.","title":"Application architecture"},{"location":"exercise-2/#prerequisites","text":"You should have already carried out the prerequisites defined in the Pre-work section. In addition to the pre-reqs above, we need to clone the repo: https://github.com/IBM/cloudpakforapps-workshop We recommend putting this repo in your user home, i.e.: cd ~ git clone https://github.com/IBM/cloudpakforapps-workshop","title":"Prerequisites"},{"location":"exercise-2/#steps","text":"Create the frontend application and run it locally Create the backend application and run it locally","title":"Steps"},{"location":"exercise-2/#1-create-the-frontend-application-and-run-it-locally","text":"The frontend application is written in Node.js Express. First let's initialize an Appsody project that uses the Node.js Express stack. Create a directory somewhere outside where you cloned this project and run the appsody init command shown below. cd ~/appsody-apps mkdir quote-frontend cd quote-frontend appsody init kabanero/nodejs-express After appsody init completes, list the content of the directory. You'll see that Appsody has created a starter application for you. . \u251c\u2500\u2500 app.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u2514\u2500\u2500 test \u2514\u2500\u2500 test.js It's possible to run this application on your workstation immediately. appsody run You can see the output of the application by navigating to http://localhost:3000 in a browser window. Appsody builds a containerized version of the application for you and runs it in Docker. You can enter http://localhost:3000 in a browser to see the default endpoint served by the application. The Node.js Express stack also provides out-of-the-box health checking, application metrics endpoints and performance monitoring. In development containers (i.e. during Rapid Local Development Mode), it also provides an analysis dashboard. Health endpoint: http://localhost:3000/health Liveness endpoint: http://localhost:3000/live Readiness endpoint: http://localhost:3000/ready Metrics endpoint: http://localhost:3000/metrics Dashboard endpoint: http://localhost:3000/appmetrics-dash (development only) While the containerized application is running you can edit the application and your changes will be reflected in the running container. You can test this by editing the app.js module and changing the message returned by the default endpoint. Watch the appsody run console session for the application to restart. Then re-enter http://localhost:3000 in your browser and you will see the new message. We're going to replace the starter code with the insurance quote frontend application. First you must edit the package.json file and add the following to the dependencies section: { . . \"dependencies\" : { \"body-parser\" : \"^1.19.0\" , \"config\" : \"^3.2.0\" , \"express-validator\" : \"^6.2.0\" , \"pug\" : \"^2.0.0\" , \"request\" : \"^2.88.0\" }, . . . } The Node.js Express stack installs the package dependencies into the containerized application. However it won't do this when the containerized application is already running. You must stop the current application by entering appsody stop in a separate window, and then re-run appsody run to start it back up. Now copy the files from the quote-frontend directory in the cloned git repo to your Appsody project, for example: cp -R ~/cloudpakforapps-workshop/exercise-frontend/* . The resulting directory structure of your Appsody project should look like this: . \u2514\u2500\u2500 config \u251c\u2500\u2500 custom-environment-variables.json \u2514\u2500\u2500 development.json \u2514\u2500\u2500 test \u2514\u2500\u2500 test.js \u2514\u2500\u2500 views \u2514\u2500\u2500 quote.pug \u251c\u2500\u2500 app.js \u251c\u2500\u2500 package-lock.json \u251c\u2500\u2500 package.json \u2514\u2500\u2500 quote.js Watch for the container to restart and then refresh your browser again. You will see a form appear. You can fill in the form and hit the button to submit it and a response will appear. In this case the frontend application is not sending a request to the backend application. Instead it is configured to use a mock endpoint for testing purposes in development mode. This works as follows. quote.js uses the config module to get the value for the backend URL. When the application runs in development mode, the config module uses config/development.json to find the value for the backend URL. This file sets the URL to the mock endpoint. { \"backendUrl\" : \"http://localhost:3000/quote/test\" } When the application runs in production mode (which we'll see later), the config module uses config/custom-environment-variables.json to find the value for the backend URL. This file sets the URL from the BACKEND_URL environment variable. { \"backendUrl\" : \"BACKEND_URL\" } Press Ctrl-C in the window where the application is running to stop it. Appsody provides a way to run automated tests against the containerized application. appsody test This runs tests that come packaged with the stack (such as tests of the health and metrics endpoints), and of course you can add your own tests of your application as well. Look at tests that call GET /quote and POST /quote in test/test.js to how the frontend application is tested.","title":"1. Create the frontend application and run it locally"},{"location":"exercise-2/#2-create-the-backend-application-and-run-it-locally","text":"The backend application is written in Spring Boot. Let's initialize an Appsody project that uses the Spring Boot 2 stack. Create a directory somewhere outside where you cloned this project and run the appsody init command shown below. cd ~/appsody-apps mkdir quote-backend cd quote-backend appsody init kabanero/java-spring-boot2 After appsody init completes, list the content of the directory. You'll see that Appsody has created a starter application for you. . \u251c\u2500\u2500 src/main/java/application/LivenessEndpoint.java \u251c\u2500\u2500 /Main.java \u251c\u2500\u2500 src/main/resources/public/index.html \u251c\u2500\u2500 /application.properties \u251c\u2500\u2500 test/java/application/MainTests.java \u251c\u2500\u2500 target/* ( compiled code ) \u251c\u2500\u2500 .appsody-config.yaml \u251c\u2500\u2500 .gitignore \u2514\u2500\u2500 pom.xml It's possible to run this application on your workstation immediately. appsody run Appsody builds a containerized version of the application for you and runs it in Docker. You can enter http://localhost:8080 in a browser to see the default endpoint served by the application. The Spring Boot 2 stack also provides out-of-the-box health checking and application metrics endpoints. Health endpoint: http://localhost:8080/actuator/health Liveness endpoint: http://localhost:8080/actuator/liveness Metrics endpoint: http://localhost:8080/actuator/metrics Prometheus endpoint: http://localhost:8080/actuator/prometheus We're going to replace the starter code with the insurance quote backend application. Edit the pom.xml file and add the following dependency to the dependencies section. <dependencies> . . . <dependency> <groupId> org.projectlombok </groupId> <artifactId> lombok </artifactId> <version> 1.18.8 </version> </dependency> </dependencies> Now copy the files from the quote-backend directory in the cloned git repo to your Appsody project, for example: cp -R ~/cloudpakforapps-workshop/exercise-backend/* . The resulting directory structure of your Appsody project should look like this: . \u251c\u2500\u2500 src/main/java/application/LivenessEndpoint.java \u251c\u2500\u2500 /Main.java \u251c\u2500\u2500 src/main/resources/public/index.html \u251c\u2500\u2500 /application.properties \u251c\u2500\u2500 /application.yaml \u251c\u2500\u2500 test/java/application/MainTests.java \u251c\u2500\u2500 test/java/application/QuoteTests.java \u251c\u2500\u2500 target/* ( compiled code ) \u251c\u2500\u2500 .appsody-config.yaml \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 backend-input.json \u2514\u2500\u2500 pom.xml You can test the backend API using curl . The file backend-input.json contains sample input for the API. Issue the curl command from the project directory. curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http://localhost:8080/quote You should see output similar to the following: $ curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http://localhost:8080/quote { \"quotedAmount\" :30, \"basis\" : \"mocked backend computation\" } In this case the backend application is not sending a request to the Dacadoo health score API. Instead it is configured to use a mock endpoint for testing purposes in development mode. This works as follows: src/main/java/application/Quote.java uses @Value(\"${DACADOO_URL}\") and @Value(\"${DACADOO_APIKEY}\") to get the values of the Dacadoo Health Score API endpoint URL and the API key. src/main/resources/application.yaml defines mock values for the URL and API key. DACADOO_URL : http://localhost:8080/mockscore DACADOO_APIKEY : TEST When the application runs in production mode (which we'll see later), environment variables can be used to set the URL and API key. Environment variables override the values in the application.yaml file. Press Ctrl-C in the window where the application is running to stop it. You can use appsody test to run automated tests for this application. appsody test Look at exercise-backend/src/test/java/application/QuoteTests.java to see the tests for the backend application. Congratulations ! We have tested out our sample application locally and are ready to move on to the next step, deploying it!","title":"2. Create the backend application and run it locally"},{"location":"exercise-3/","text":"Exercise 3: Deploying to OpenShift with Appsody \u00b6 In Exercise 2 you were running the insurance quote application under \"appsody control\" in Local Rapid Development Mode (sometimes called the inner loop of development). In this exercise, we will show how to deploy the same application to OpenShift using Appsody. Appsody provides the functionaliy to build a standard Docker image for your applicaiton (including all the components from stack), for deployment to Docker or Kubernetes, enabling additional testings within these environment. In particular: appsody build will create a Docker image apposdy deploy will deploy the image to a Kubernetes cluster, by default using the Appsody Operator. For simplicity, appsody deploy will also execute a build ahead of the deployment. When you have completed this exercise, you will understand how to: deploy the applications to OpenShift using the appsody CLI Prerequisites \u00b6 You should have already carried out the prerequisites defined in the Pre-work section, and in addition: In order for the backend application to access the Dacadoo Health Score API, visit https://models.dacadoo.com/doc/ to register and request an API key for evaluation purposes. Access to this API is usually granted individually to those that apply. You need to record the url for the API (displayed by clicking on the Health Score link under Models - usually https://models.dacadoo.com/score/2 ) and the Key (something similar to UFDzMHAfsEg0oKzGp4rCSmXPClKKq3hDPLbPdvc2h ). There is a mock implementation of the API in the code that you can use if you do not want to register. Steps \u00b6 Set up a project namespace Access the internal Docker Registry Deploy the backend application to OpenShift Deploy the frontend application to OpenShift 1. Set up a project namespace \u00b6 OpenShift applications are deployed within a project. So the first step is to create a new project: oc new-project insurance-quote You should see output similar to the following: $ oc new-project insurance-quote Now using project \"insurance-quote\" on server \"https://c100-e.us-east.containers.cloud.ibm.com:31718\" . You can add applications to this project with the 'new-app' command. For example, try: oc new-app centos/ruby-25-centos7~https://github.com/sclorg/ruby-ex.git to build a new example application in Ruby. Check that the current context is your team\u2019s project space. oc project -q 2. Access the internal Docker Registry \u00b6 We need a spot to push our newly built Docker images that Appsody created for us. Luckily, OpenShift comes with an internal Docker registry we can use. However, this registry is not enabled for public access by default. Running the oc get route --all-namespaces command below shows us that only a dashboard for the registry is available. Not quite what we need. oc get route --all-namespaces | grep registry You should see output similar to the following: $ oc get route --all-namespaces | grep registry default registry-console registry-console-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud To access the internal registry we need to create a route and expose it. See the IBM Cloud documentation for the complete steps, but here is the short version. Run the following to create a new route. oc create route reencrypt docker-registry --service = docker-registry -n default We can now get the Docker registry URL: oc get route --all-namespaces | grep registry You should see output similar to the following: $ oc get route --all-namespaces | grep registry default docker-registry docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud default registry-console registry-console-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud The URL we want to use is the docker-registry one, it'll look like docker-registry-default.*.containers.appdomain.cloud . Once we have the URL, set it as a variable: export IMAGE_REGISTRY = <docker_url> And set our local docker command to use that registry, use docker login : oc whoami -t | docker login -u $( oc whoami ) --password-stdin $IMAGE_REGISTRY 3. Deploy the backend application to OpenShift \u00b6 We will use the appsody deploy command for the deployments. This command: builds a deployment image for production usage (i.e. it does not include development-mode tools) pushes the image to your designated image registry builds a deployment yaml file (if you have not generated one already), as a CR for the Appsody Operator applies the yaml file to your Kubernetes cluster Appsody has the ability to deploy directly to a kubernetes cluster using a default deployment manifest. This will work if the cluster does not require any specific credentials. In this case, we will need to provide these, so appsody allows you to generate the deployment manifest it would have used, but without doing the actual deployment. We can then modify this, and then ask appsody to use it for the deployment of our applications. 3.1 Create a config map for the Dacadoo API key \u00b6 In order to have the backend application send requests to the Dacadoo Health Score API, we need to create a secret that contains the configuration for making requests to the Dacadoo server, that you obtained in the pre-requisites of this exercise. (Note: If you do not want to use the Dacadoo Health Score API, you can skip this setup and continue to use the mock endpoint.) oc create configmap dacadoo-config --from-literal = DACADOO_URL = <url> --from-literal = DACADOO_APIKEY = <apikey> where: <url> is the URL of the Dacadoo server (usually https://models.dacadoo.com/score/2 ) <apikey> is the API key that you obtained when you registered to use the API. for example: oc create configmap dacadoo-config --from-literal = DACADOO_URL = https://models.dacadoo.com/score/2 --from-literal = DACADOO_APIKEY = Y3VB...RMGG configmap/dacadoo-config created 3.2 Deploy the backend application \u00b6 Navigate to your quote-backend directory. We need to modify the deployment yaml to pass the secret's values to the application. The initial deployment yaml can be generated as follows. cd ~/appsody-apps/quote-backend appsody deploy --generate-only This creates a file named app-deploy.yaml in your project. apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-backend spec : # Add fields here version : 1.0.0 applicationImage : dev.local/quote-backend stack : java-spring-boot2 service : type : NodePort port : 8080 annotations : prometheus.io/scrape : 'true' prometheus.io/path : '/actuator/prometheus' readinessProbe : failureThreshold : 12 httpGet : path : /actuator/health port : 8080 initialDelaySeconds : 5 periodSeconds : 2 livenessProbe : failureThreshold : 12 httpGet : path : /actuator/liveness port : 8080 initialDelaySeconds : 5 periodSeconds : 2 expose : true createKnativeService : false We need to add a section to the generated file. Under the spec key, create a new envFrom key that has the value of your OpenShift config map. dacadoo-config was used as the name in this workshop. TIP : Ensure there are two spaces before name , see https://github.com/kubernetes/kubernetes/issues/46826#issuecomment-305728020 apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-backend spec : # Add fields here version : 1.0.0 . . envFrom : - configMapRef : name : dacadoo-config expose : true createKnativeService : false Now use appsody deploy to push the image and deploy it. When using the OpenShift docker registry, the urls used to push and pull a given image are different. appsody deploy allows us to specify these on the command line: appsody deploy --tag insurance-quote/quote-backend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote $ appsody deploy --tag insurance-quote/quote-backend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote . . [ Docker ] Successfully built 4294712e0f9e [ Docker ] Successfully tagged docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Built docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Using applicationImage of: docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Pushing docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Attempting to apply resource in Kubernetes ... Running command: kubectl apply -f app-deploy.yaml --namespace insurance-quote Deployment succeeded. Appsody Deployment name is: quote-backend Running command: kubectl get rt quote-backend -o jsonpath = \"{.status.url}\" --namespace insurance-quote Attempting to get resource from Kubernetes ... Running command: kubectl get route quote-backend -o jsonpath ={ .status.ingress [ 0 ] .host } --namespace insurance-quote Deployed project running at quote-backend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud NOTE : If the deployment times out, see the section Pushing to the OpenShift registry times out in the Admin Guide. NOTE : Running appsody deploy will install the appsody operator on the Default namespace of the cluster. After the deployment completes, you can test the service using curl. The last line output (above) in the deploy gives you the url to the backend application. For simplicity, let's put that in an environment variable, i.e, for the example above: export BACKEND_URL = quote-backend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http:// $BACKEND_URL /quote You should see output similar to the following: $ curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http:// $BACKEND_URL /quote { \"quotedAmount\" :70, \"basis\" : \"Dacadoo Health Score API\" } NOTE : If you are not using the Dacadoo Health Score API, you may see different text for the value of \"basis\" -- (\"mocked backend computation\" instead of \"Dacadoo Health Score API\"). Navigating back to the registry dashboard should show the new image. 4. Deploy the frontend application to OpenShift \u00b6 We are now going to deploy the frontend application to OpenShift. The steps are similar to what we did for the backend application. The difference here is that we need to tell the frontend application how to talk to the backend application. The frontend will look at an environment variable BACKEND_URL to find the address of the backend, so we will set this in the application CR. Now we could specify this as the actual exposed backend url we used earlier, however since both front and backend are running within the same cluster, it is better to use the service that is defined for the backend. You can see this by entering: oc get services which should produce something like: $ oc get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE quote-backend NodePort 172 .21.175.254 <none> 8080 :32379/TCP 15m In order to be able to reference this in the application CR, we first we need to generate the deployment yaml so that we can edit it. Change the current directory back to the frontend application and generate the deployment yaml. cd ../quote-frontend appsody deploy --generate-only Edit the file that was created, app-deploy.yaml , and add the env section as shown below (which defines an environment variable with the URL of the backend application within the cluster). Be careful to match the indentation ( env: is indented the same number of spaces as applicationImage: ): apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-frontend spec : # Add fields here version : 1.0.0 applicationImage : quote-frontend env : - name : BACKEND_URL value : http://quote-backend:8080/quote . . . Save the yaml file and do the deployment. appsody deploy --tag insurance-quote/quote-frontend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote $ appsody deploy --tag insurance-quote/quote-frontend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote ... [ Docker ] Successfully built ba7451568a04 [ Docker ] Successfully tagged docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Built docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Using applicationImage of: docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Pushing docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Attempting to apply resource in Kubernetes ... Running command: kubectl apply -f app-deploy.yaml --namespace insurance-quote Deployment succeeded. Appsody Deployment name is: quote-frontend Running command: kubectl get rt quote-frontend -o jsonpath = \"{.status.url}\" --namespace insurance-quote Attempting to get resource from Kubernetes ... Running command: kubectl get route quote-frontend -o jsonpath ={ .status.ingress [ 0 ] .host } --namespace insurance-quote Deployed project running at quote-frontend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud You can then use a browser to open the frontend application, at the url given above (in the example above the URL is quote-frontend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud ). Fill in the form and click the button to submit it. You should get a quote from the backend application. NOTE : If you are not using the Dacadoo Health Score API, you may see different text after the quote (\"determined using mocked backend computation\" instead of \"determined using Dacadoo Health Score API\"). Congratulations ! You have now deployed both front and backend applications to OpenShift, hooked them together as well as enable outreach to an external service. In general, using appsody to deploy your application in this fashion is recommended only to enable additional testing within a Docker or Kubernetes environment. As you are probably aware, using such a manual approach inside formal test, staging and production environments doesn't solve the problems of maintaining consistency, repeatability and control. In later exercises we will learn how to use appsody and kabanero to achieve these - using a Tekton pipeline, hooked to a git repository of the code of the application, ensuring triggering of automated builds and deployments. This is the recommended methodology supported by Kabanero and Cloud Pak for Applications.","title":"Lab 3. Deploying to OpenShift with Appsody"},{"location":"exercise-3/#exercise-3-deploying-to-openshift-with-appsody","text":"In Exercise 2 you were running the insurance quote application under \"appsody control\" in Local Rapid Development Mode (sometimes called the inner loop of development). In this exercise, we will show how to deploy the same application to OpenShift using Appsody. Appsody provides the functionaliy to build a standard Docker image for your applicaiton (including all the components from stack), for deployment to Docker or Kubernetes, enabling additional testings within these environment. In particular: appsody build will create a Docker image apposdy deploy will deploy the image to a Kubernetes cluster, by default using the Appsody Operator. For simplicity, appsody deploy will also execute a build ahead of the deployment. When you have completed this exercise, you will understand how to: deploy the applications to OpenShift using the appsody CLI","title":"Exercise 3: Deploying to OpenShift with Appsody"},{"location":"exercise-3/#prerequisites","text":"You should have already carried out the prerequisites defined in the Pre-work section, and in addition: In order for the backend application to access the Dacadoo Health Score API, visit https://models.dacadoo.com/doc/ to register and request an API key for evaluation purposes. Access to this API is usually granted individually to those that apply. You need to record the url for the API (displayed by clicking on the Health Score link under Models - usually https://models.dacadoo.com/score/2 ) and the Key (something similar to UFDzMHAfsEg0oKzGp4rCSmXPClKKq3hDPLbPdvc2h ). There is a mock implementation of the API in the code that you can use if you do not want to register.","title":"Prerequisites"},{"location":"exercise-3/#steps","text":"Set up a project namespace Access the internal Docker Registry Deploy the backend application to OpenShift Deploy the frontend application to OpenShift","title":"Steps"},{"location":"exercise-3/#1-set-up-a-project-namespace","text":"OpenShift applications are deployed within a project. So the first step is to create a new project: oc new-project insurance-quote You should see output similar to the following: $ oc new-project insurance-quote Now using project \"insurance-quote\" on server \"https://c100-e.us-east.containers.cloud.ibm.com:31718\" . You can add applications to this project with the 'new-app' command. For example, try: oc new-app centos/ruby-25-centos7~https://github.com/sclorg/ruby-ex.git to build a new example application in Ruby. Check that the current context is your team\u2019s project space. oc project -q","title":"1. Set up a project namespace"},{"location":"exercise-3/#2-access-the-internal-docker-registry","text":"We need a spot to push our newly built Docker images that Appsody created for us. Luckily, OpenShift comes with an internal Docker registry we can use. However, this registry is not enabled for public access by default. Running the oc get route --all-namespaces command below shows us that only a dashboard for the registry is available. Not quite what we need. oc get route --all-namespaces | grep registry You should see output similar to the following: $ oc get route --all-namespaces | grep registry default registry-console registry-console-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud To access the internal registry we need to create a route and expose it. See the IBM Cloud documentation for the complete steps, but here is the short version. Run the following to create a new route. oc create route reencrypt docker-registry --service = docker-registry -n default We can now get the Docker registry URL: oc get route --all-namespaces | grep registry You should see output similar to the following: $ oc get route --all-namespaces | grep registry default docker-registry docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud default registry-console registry-console-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud The URL we want to use is the docker-registry one, it'll look like docker-registry-default.*.containers.appdomain.cloud . Once we have the URL, set it as a variable: export IMAGE_REGISTRY = <docker_url> And set our local docker command to use that registry, use docker login : oc whoami -t | docker login -u $( oc whoami ) --password-stdin $IMAGE_REGISTRY","title":"2. Access the internal Docker Registry"},{"location":"exercise-3/#3-deploy-the-backend-application-to-openshift","text":"We will use the appsody deploy command for the deployments. This command: builds a deployment image for production usage (i.e. it does not include development-mode tools) pushes the image to your designated image registry builds a deployment yaml file (if you have not generated one already), as a CR for the Appsody Operator applies the yaml file to your Kubernetes cluster Appsody has the ability to deploy directly to a kubernetes cluster using a default deployment manifest. This will work if the cluster does not require any specific credentials. In this case, we will need to provide these, so appsody allows you to generate the deployment manifest it would have used, but without doing the actual deployment. We can then modify this, and then ask appsody to use it for the deployment of our applications.","title":"3. Deploy the backend application to OpenShift"},{"location":"exercise-3/#31-create-a-config-map-for-the-dacadoo-api-key","text":"In order to have the backend application send requests to the Dacadoo Health Score API, we need to create a secret that contains the configuration for making requests to the Dacadoo server, that you obtained in the pre-requisites of this exercise. (Note: If you do not want to use the Dacadoo Health Score API, you can skip this setup and continue to use the mock endpoint.) oc create configmap dacadoo-config --from-literal = DACADOO_URL = <url> --from-literal = DACADOO_APIKEY = <apikey> where: <url> is the URL of the Dacadoo server (usually https://models.dacadoo.com/score/2 ) <apikey> is the API key that you obtained when you registered to use the API. for example: oc create configmap dacadoo-config --from-literal = DACADOO_URL = https://models.dacadoo.com/score/2 --from-literal = DACADOO_APIKEY = Y3VB...RMGG configmap/dacadoo-config created","title":"3.1 Create a config map for the Dacadoo API key"},{"location":"exercise-3/#32-deploy-the-backend-application","text":"Navigate to your quote-backend directory. We need to modify the deployment yaml to pass the secret's values to the application. The initial deployment yaml can be generated as follows. cd ~/appsody-apps/quote-backend appsody deploy --generate-only This creates a file named app-deploy.yaml in your project. apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-backend spec : # Add fields here version : 1.0.0 applicationImage : dev.local/quote-backend stack : java-spring-boot2 service : type : NodePort port : 8080 annotations : prometheus.io/scrape : 'true' prometheus.io/path : '/actuator/prometheus' readinessProbe : failureThreshold : 12 httpGet : path : /actuator/health port : 8080 initialDelaySeconds : 5 periodSeconds : 2 livenessProbe : failureThreshold : 12 httpGet : path : /actuator/liveness port : 8080 initialDelaySeconds : 5 periodSeconds : 2 expose : true createKnativeService : false We need to add a section to the generated file. Under the spec key, create a new envFrom key that has the value of your OpenShift config map. dacadoo-config was used as the name in this workshop. TIP : Ensure there are two spaces before name , see https://github.com/kubernetes/kubernetes/issues/46826#issuecomment-305728020 apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-backend spec : # Add fields here version : 1.0.0 . . envFrom : - configMapRef : name : dacadoo-config expose : true createKnativeService : false Now use appsody deploy to push the image and deploy it. When using the OpenShift docker registry, the urls used to push and pull a given image are different. appsody deploy allows us to specify these on the command line: appsody deploy --tag insurance-quote/quote-backend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote $ appsody deploy --tag insurance-quote/quote-backend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote . . [ Docker ] Successfully built 4294712e0f9e [ Docker ] Successfully tagged docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Built docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Using applicationImage of: docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Pushing docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:v1 Attempting to apply resource in Kubernetes ... Running command: kubectl apply -f app-deploy.yaml --namespace insurance-quote Deployment succeeded. Appsody Deployment name is: quote-backend Running command: kubectl get rt quote-backend -o jsonpath = \"{.status.url}\" --namespace insurance-quote Attempting to get resource from Kubernetes ... Running command: kubectl get route quote-backend -o jsonpath ={ .status.ingress [ 0 ] .host } --namespace insurance-quote Deployed project running at quote-backend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud NOTE : If the deployment times out, see the section Pushing to the OpenShift registry times out in the Admin Guide. NOTE : Running appsody deploy will install the appsody operator on the Default namespace of the cluster. After the deployment completes, you can test the service using curl. The last line output (above) in the deploy gives you the url to the backend application. For simplicity, let's put that in an environment variable, i.e, for the example above: export BACKEND_URL = quote-backend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http:// $BACKEND_URL /quote You should see output similar to the following: $ curl -X POST -d @backend-input.json -H \"Content-Type: application/json\" http:// $BACKEND_URL /quote { \"quotedAmount\" :70, \"basis\" : \"Dacadoo Health Score API\" } NOTE : If you are not using the Dacadoo Health Score API, you may see different text for the value of \"basis\" -- (\"mocked backend computation\" instead of \"Dacadoo Health Score API\"). Navigating back to the registry dashboard should show the new image.","title":"3.2 Deploy the backend application"},{"location":"exercise-3/#4-deploy-the-frontend-application-to-openshift","text":"We are now going to deploy the frontend application to OpenShift. The steps are similar to what we did for the backend application. The difference here is that we need to tell the frontend application how to talk to the backend application. The frontend will look at an environment variable BACKEND_URL to find the address of the backend, so we will set this in the application CR. Now we could specify this as the actual exposed backend url we used earlier, however since both front and backend are running within the same cluster, it is better to use the service that is defined for the backend. You can see this by entering: oc get services which should produce something like: $ oc get services NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE quote-backend NodePort 172 .21.175.254 <none> 8080 :32379/TCP 15m In order to be able to reference this in the application CR, we first we need to generate the deployment yaml so that we can edit it. Change the current directory back to the frontend application and generate the deployment yaml. cd ../quote-frontend appsody deploy --generate-only Edit the file that was created, app-deploy.yaml , and add the env section as shown below (which defines an environment variable with the URL of the backend application within the cluster). Be careful to match the indentation ( env: is indented the same number of spaces as applicationImage: ): apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-frontend spec : # Add fields here version : 1.0.0 applicationImage : quote-frontend env : - name : BACKEND_URL value : http://quote-backend:8080/quote . . . Save the yaml file and do the deployment. appsody deploy --tag insurance-quote/quote-frontend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote $ appsody deploy --tag insurance-quote/quote-frontend:v1 --push-url $IMAGE_REGISTRY --push --pull-url docker-registry.default.svc:5000 --namespace insurance-quote ... [ Docker ] Successfully built ba7451568a04 [ Docker ] Successfully tagged docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Built docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Using applicationImage of: docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Pushing docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-frontend:v1 Attempting to apply resource in Kubernetes ... Running command: kubectl apply -f app-deploy.yaml --namespace insurance-quote Deployment succeeded. Appsody Deployment name is: quote-frontend Running command: kubectl get rt quote-frontend -o jsonpath = \"{.status.url}\" --namespace insurance-quote Attempting to get resource from Kubernetes ... Running command: kubectl get route quote-frontend -o jsonpath ={ .status.ingress [ 0 ] .host } --namespace insurance-quote Deployed project running at quote-frontend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud You can then use a browser to open the frontend application, at the url given above (in the example above the URL is quote-frontend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud ). Fill in the form and click the button to submit it. You should get a quote from the backend application. NOTE : If you are not using the Dacadoo Health Score API, you may see different text after the quote (\"determined using mocked backend computation\" instead of \"determined using Dacadoo Health Score API\"). Congratulations ! You have now deployed both front and backend applications to OpenShift, hooked them together as well as enable outreach to an external service. In general, using appsody to deploy your application in this fashion is recommended only to enable additional testing within a Docker or Kubernetes environment. As you are probably aware, using such a manual approach inside formal test, staging and production environments doesn't solve the problems of maintaining consistency, repeatability and control. In later exercises we will learn how to use appsody and kabanero to achieve these - using a Tekton pipeline, hooked to a git repository of the code of the application, ensuring triggering of automated builds and deployments. This is the recommended methodology supported by Kabanero and Cloud Pak for Applications.","title":"4. Deploy the frontend application to OpenShift"},{"location":"exercise-4/","text":"Exercise 4: Use Tekton and Kabanero Pipelines to continuously deploy \u00b6 In this exercise we're going to take our insurance quote application from exercise 3 and instead of deploying it as a stand alone app, we will push the code up to a GitHub repo and use Tekton pipelines to automatically deploy the app to our OpenShift cluster and speed up your deployment process. Recall that the application from exercise 3 consists of: a front-end constructed with Node.js (we used the nodejs-express collection) a back-end constructed with Java (we used the java-spring-boot2 collection) When you have completed this exercise, you will understand how to: leverage Tekton pipelines with Collections to deploy applications to OpenShift Prerequisites \u00b6 You should have already carried out the prerequisites defined in Exercise 3 , and in addition: First we delete the deployments, run the appsody deploy delete command to remove them. cd ~/appsody-apps/quote-frontend appsody deploy delete --namespace insurance-quote cd ~/appsody-apps/quote-backend appsody deploy delete --namespace insurance-quote You should see output similar to the following: $ appsody deploy delete --namespace insurance-quote Deleting deployment using deployment manifest app-deploy.yaml Attempting to delete resource from Kubernetes... Running command: kubectl delete -f app-deploy.yaml --namespace insurance-quote Deployment deleted Note, we still have the insurance-quote namespace, the dacadoo-config config map, the appsody-operator deployment, and the images in our registry. Steps \u00b6 Launch the Tekton dashboard Get a GitHub Access Token Upload insurance quote frontend, and backend to GitHub Add webhooks to Tekton to watch Github repo changes Test it all out 1. Launch the Tekton dashboard \u00b6 You can launch the tekton dashboard by accessing the Cloud Pak for Applications dashboard and selecting the Tekton link. Revisit the Pre-work section if unable to recall how to access the Cloud Pak for Applications dashboard. You can also obtain the URL for the tekton dashboard by using oc get routes . We want to use the address that looks like tekton-dashboard-kabanero.xyz.domain.containers.appdomain.cloud . $ oc get routes --namespace kabanero NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD icpa-landing ibm-cp-applications.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud icpa-landing <all> reencrypt/Redirect None kabanero-cli kabanero-cli-kabanero.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud kabanero-cli <all> passthrough None kabanero-landing kabanero-landing-kabanero.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud kabanero-landing <all> passthrough None tekton-dashboard tekton-dashboard-kabanero.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud tekton-dashboard <all> reencrypt/Redirect None Review pre-installed pipelines and tasks on Cloud Pak for Apps \u00b6 There are 5 Pipelines , one for each collection kabanero comes with (java microprofile, spring, nodejs, express, and loopback). Pipelines are a first class structure in Tekton. Pipelines are a series of Tasks . Run this command to see the available pipelines. oc get pipeline -n kabanero You will see something similar to this. $ oc get pipeline -n kabanero NAME AGE java-microprofile-build-deploy-pipeline 15d java-spring-boot2-build-deploy-pipeline 15d nodejs-build-deploy-pipeline 15d nodejs-express-build-deploy-pipeline 15d nodejs-loopback-build-deploy-pipeline 15d pipeline0 15d These are visible through the UI, too: There are 10 Tasks , two for each collection kabanero comes with. Each collection has 2 Tasks , a Build Task and a Deploy Task . oc get tasks -n kabanero You will see something similar to this. $ oc get tasks -n kabanero NAME AGE java-microprofile-build-task 27d java-microprofile-deploy-task 27d java-spring-boot2-build-task 27d java-spring-boot2-deploy-task 27d monitor-result-task 27d nodejs-build-task 27d nodejs-deploy-task 27d nodejs-express-build-task 27d nodejs-express-deploy-task 27d nodejs-loopback-build-task 27d nodejs-loopback-deploy-task 27d pipeline0-task 27d These are visible through the UI, too: 2. Update Kabanero to deploy to alternate namespaces with Tekton \u00b6 Out of the box, Kabanero will only allow deployments to the kabanero namespace. It is recommended that you create separate namespaces either for individual applications or classes of application. To do this, you need to add these new namespaces to the kabanero custom resource. To find this resource $ oc get kabaneros -n kabanero NAME AGE VERSION READY kabanero 13d 0 .1.0 True Edit the kabanero custom resource oc edit kabaneros kabanero -n kabanero Add a targetNamespaces key to spec with, in this case, a single value of insurance-quote : spec : collections : repositories : - activateDefaultCollections : true name : incubator url : https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml targetNamespaces : - insurance-quote Update app-deploy.yml to specify the namespace \u00b6 Go to your frontend code cd ~/appsody-apps/quote-frontend and update app-deploy.yaml to include the namespace apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-frontend namespace : insurance-quote Go to your backend code cd ~/appsody-apps/quote-backend and update app-deploy.yaml to include the namespace apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-backend namespace : insurance-quote 2. Get a GitHub Access Token \u00b6 When using Tekton, building a pipeline will require code to be pulled from either a public or private repository. When configuring Tekton, for security reasons, we will create an Access Token instead of using a password. To create an Access Token , from Github.com click on your profile icon in the top left. Then go to Settings -> Developer Settings -> Personal Access Tokens . Or go directly to https://github.com/settings/tokens Here we want to generate a token, so Click on the Generate a Token . The token permissions need to be the repo which gives read and write access to the repository. Once the token is created, make sure to copy it down. We will need it later. 3. Upload insurance quote frontend, and backend to GitHub \u00b6 Go to https://github.com/new and create two new repositories, quote-frontend , and quote-backend . Do not initiatize the repos with a license file or README. From your quote-backend directory, run the commands below, replacing <username> with your own. git init git add -A git commit -m \"first commit\" git remote add origin git@github.com:<username>/quote-backend.git git push -u origin master The repo for your backend code should look like this: From your quote-frontend directory, run the commands below, replacing <username> with your own. git init git add -A git commit -m \"first commit\" git remote add origin git@github.com:<username>/quote-frontend.git git push -u origin master The repo for your frontend code should look like this: 4. Add webhooks to Tekton to watch Github repo changes \u00b6 Configure the GitHub webhook to your repo. Go to Webhooks > Add Webhook and then create the webhook. Note that the first time creating a webhook a new access token must also be created, use the access token from the earlier step: Create a webhook for the backend \u00b6 Name: backend-webhook Repository URL: http://github.com/{username}/quote-backend Access Token: github-tekton Namespace: kabanero Pipeline: java-spring-boot2-build-deploy-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/insurance-quote Create a webhook for the frontend \u00b6 Name: frontend-webhook Repository URL: http://github.com/{username}/quote-frontend Access Token: github-tekton Namespace: kabanero Pipeline: nodejs-express-build-deploy-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/insurance-quote Verify both are created successfully. Check Github repo settings \u00b6 Go to the repo and check the settings tab to see the webhooks, Click the webhook Scroll down to see any payloads being delivered. There is currently a bug where the first payload is not delivered. Not to worry, we'll be making changes to the code anyway, that will trigger a new payload. 5. Test it all out \u00b6 In your quote-backend repo, change the file quote-backend/src/main/java/application/Quote.java . Change a value in a logger statement. Then commit this change and push to your github repo, for example: git add -u git commit -m \"test change\" git push -f -u origin master This will trigger the java-spring-boot2-build-deploy tekton pipeline. Go to the tekton dashboard and access the new pipeline run it created. Wait until the task is complete, and then in your quote-frontend repo, change the file quote-frontend/app.js . Change a value in a comment statement. Then commit this change and push to your github repo, for example: git add -u git commit -m \"test change\" git push -f -u origin master This should trigger another pipeline run to be created, using the nodejs-express-build-deploy pipeline. Wait until the task is complete, then find the route using oc get routes : $ oc get routes -n insurance-quote | grep frontend quote-frontend quote-frontend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud Open a browser to http://<url-from-above> and see the usual interface for the insurance quote app. Try entering information to ensure the frontend and backend are communicating. Congratulations ! You have deployed the sample application to OpenShift using Tekton. Day 1 of the workshop is now complete!","title":"Lab 4. Use Tekton to continuously deploy"},{"location":"exercise-4/#exercise-4-use-tekton-and-kabanero-pipelines-to-continuously-deploy","text":"In this exercise we're going to take our insurance quote application from exercise 3 and instead of deploying it as a stand alone app, we will push the code up to a GitHub repo and use Tekton pipelines to automatically deploy the app to our OpenShift cluster and speed up your deployment process. Recall that the application from exercise 3 consists of: a front-end constructed with Node.js (we used the nodejs-express collection) a back-end constructed with Java (we used the java-spring-boot2 collection) When you have completed this exercise, you will understand how to: leverage Tekton pipelines with Collections to deploy applications to OpenShift","title":"Exercise 4: Use Tekton and Kabanero Pipelines to continuously deploy"},{"location":"exercise-4/#prerequisites","text":"You should have already carried out the prerequisites defined in Exercise 3 , and in addition: First we delete the deployments, run the appsody deploy delete command to remove them. cd ~/appsody-apps/quote-frontend appsody deploy delete --namespace insurance-quote cd ~/appsody-apps/quote-backend appsody deploy delete --namespace insurance-quote You should see output similar to the following: $ appsody deploy delete --namespace insurance-quote Deleting deployment using deployment manifest app-deploy.yaml Attempting to delete resource from Kubernetes... Running command: kubectl delete -f app-deploy.yaml --namespace insurance-quote Deployment deleted Note, we still have the insurance-quote namespace, the dacadoo-config config map, the appsody-operator deployment, and the images in our registry.","title":"Prerequisites"},{"location":"exercise-4/#steps","text":"Launch the Tekton dashboard Get a GitHub Access Token Upload insurance quote frontend, and backend to GitHub Add webhooks to Tekton to watch Github repo changes Test it all out","title":"Steps"},{"location":"exercise-4/#1-launch-the-tekton-dashboard","text":"You can launch the tekton dashboard by accessing the Cloud Pak for Applications dashboard and selecting the Tekton link. Revisit the Pre-work section if unable to recall how to access the Cloud Pak for Applications dashboard. You can also obtain the URL for the tekton dashboard by using oc get routes . We want to use the address that looks like tekton-dashboard-kabanero.xyz.domain.containers.appdomain.cloud . $ oc get routes --namespace kabanero NAME HOST/PORT PATH SERVICES PORT TERMINATION WILDCARD icpa-landing ibm-cp-applications.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud icpa-landing <all> reencrypt/Redirect None kabanero-cli kabanero-cli-kabanero.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud kabanero-cli <all> passthrough None kabanero-landing kabanero-landing-kabanero.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud kabanero-landing <all> passthrough None tekton-dashboard tekton-dashboard-kabanero.cpa-workshop-dev-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud tekton-dashboard <all> reencrypt/Redirect None","title":"1. Launch the Tekton dashboard"},{"location":"exercise-4/#review-pre-installed-pipelines-and-tasks-on-cloud-pak-for-apps","text":"There are 5 Pipelines , one for each collection kabanero comes with (java microprofile, spring, nodejs, express, and loopback). Pipelines are a first class structure in Tekton. Pipelines are a series of Tasks . Run this command to see the available pipelines. oc get pipeline -n kabanero You will see something similar to this. $ oc get pipeline -n kabanero NAME AGE java-microprofile-build-deploy-pipeline 15d java-spring-boot2-build-deploy-pipeline 15d nodejs-build-deploy-pipeline 15d nodejs-express-build-deploy-pipeline 15d nodejs-loopback-build-deploy-pipeline 15d pipeline0 15d These are visible through the UI, too: There are 10 Tasks , two for each collection kabanero comes with. Each collection has 2 Tasks , a Build Task and a Deploy Task . oc get tasks -n kabanero You will see something similar to this. $ oc get tasks -n kabanero NAME AGE java-microprofile-build-task 27d java-microprofile-deploy-task 27d java-spring-boot2-build-task 27d java-spring-boot2-deploy-task 27d monitor-result-task 27d nodejs-build-task 27d nodejs-deploy-task 27d nodejs-express-build-task 27d nodejs-express-deploy-task 27d nodejs-loopback-build-task 27d nodejs-loopback-deploy-task 27d pipeline0-task 27d These are visible through the UI, too:","title":"Review pre-installed pipelines and tasks on Cloud Pak for Apps"},{"location":"exercise-4/#2-update-kabanero-to-deploy-to-alternate-namespaces-with-tekton","text":"Out of the box, Kabanero will only allow deployments to the kabanero namespace. It is recommended that you create separate namespaces either for individual applications or classes of application. To do this, you need to add these new namespaces to the kabanero custom resource. To find this resource $ oc get kabaneros -n kabanero NAME AGE VERSION READY kabanero 13d 0 .1.0 True Edit the kabanero custom resource oc edit kabaneros kabanero -n kabanero Add a targetNamespaces key to spec with, in this case, a single value of insurance-quote : spec : collections : repositories : - activateDefaultCollections : true name : incubator url : https://github.com/kabanero-io/collections/releases/download/v0.1.2/kabanero-index.yaml targetNamespaces : - insurance-quote","title":"2. Update Kabanero to deploy to alternate namespaces with Tekton"},{"location":"exercise-4/#update-app-deployyml-to-specify-the-namespace","text":"Go to your frontend code cd ~/appsody-apps/quote-frontend and update app-deploy.yaml to include the namespace apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-frontend namespace : insurance-quote Go to your backend code cd ~/appsody-apps/quote-backend and update app-deploy.yaml to include the namespace apiVersion : appsody.dev/v1beta1 kind : AppsodyApplication metadata : name : quote-backend namespace : insurance-quote","title":"Update app-deploy.yml to specify the namespace"},{"location":"exercise-4/#2-get-a-github-access-token","text":"When using Tekton, building a pipeline will require code to be pulled from either a public or private repository. When configuring Tekton, for security reasons, we will create an Access Token instead of using a password. To create an Access Token , from Github.com click on your profile icon in the top left. Then go to Settings -> Developer Settings -> Personal Access Tokens . Or go directly to https://github.com/settings/tokens Here we want to generate a token, so Click on the Generate a Token . The token permissions need to be the repo which gives read and write access to the repository. Once the token is created, make sure to copy it down. We will need it later.","title":"2. Get a GitHub Access Token"},{"location":"exercise-4/#3-upload-insurance-quote-frontend-and-backend-to-github","text":"Go to https://github.com/new and create two new repositories, quote-frontend , and quote-backend . Do not initiatize the repos with a license file or README. From your quote-backend directory, run the commands below, replacing <username> with your own. git init git add -A git commit -m \"first commit\" git remote add origin git@github.com:<username>/quote-backend.git git push -u origin master The repo for your backend code should look like this: From your quote-frontend directory, run the commands below, replacing <username> with your own. git init git add -A git commit -m \"first commit\" git remote add origin git@github.com:<username>/quote-frontend.git git push -u origin master The repo for your frontend code should look like this:","title":"3. Upload insurance quote frontend, and backend to GitHub"},{"location":"exercise-4/#4-add-webhooks-to-tekton-to-watch-github-repo-changes","text":"Configure the GitHub webhook to your repo. Go to Webhooks > Add Webhook and then create the webhook. Note that the first time creating a webhook a new access token must also be created, use the access token from the earlier step:","title":"4. Add webhooks to Tekton to watch Github repo changes"},{"location":"exercise-4/#create-a-webhook-for-the-backend","text":"Name: backend-webhook Repository URL: http://github.com/{username}/quote-backend Access Token: github-tekton Namespace: kabanero Pipeline: java-spring-boot2-build-deploy-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/insurance-quote","title":"Create a webhook for the backend"},{"location":"exercise-4/#create-a-webhook-for-the-frontend","text":"Name: frontend-webhook Repository URL: http://github.com/{username}/quote-frontend Access Token: github-tekton Namespace: kabanero Pipeline: nodejs-express-build-deploy-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/insurance-quote Verify both are created successfully.","title":"Create a webhook for the frontend"},{"location":"exercise-4/#check-github-repo-settings","text":"Go to the repo and check the settings tab to see the webhooks, Click the webhook Scroll down to see any payloads being delivered. There is currently a bug where the first payload is not delivered. Not to worry, we'll be making changes to the code anyway, that will trigger a new payload.","title":"Check Github repo settings"},{"location":"exercise-4/#5-test-it-all-out","text":"In your quote-backend repo, change the file quote-backend/src/main/java/application/Quote.java . Change a value in a logger statement. Then commit this change and push to your github repo, for example: git add -u git commit -m \"test change\" git push -f -u origin master This will trigger the java-spring-boot2-build-deploy tekton pipeline. Go to the tekton dashboard and access the new pipeline run it created. Wait until the task is complete, and then in your quote-frontend repo, change the file quote-frontend/app.js . Change a value in a comment statement. Then commit this change and push to your github repo, for example: git add -u git commit -m \"test change\" git push -f -u origin master This should trigger another pipeline run to be created, using the nodejs-express-build-deploy pipeline. Wait until the task is complete, then find the route using oc get routes : $ oc get routes -n insurance-quote | grep frontend quote-frontend quote-frontend-insurance-quote.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud Open a browser to http://<url-from-above> and see the usual interface for the insurance quote app. Try entering information to ensure the frontend and backend are communicating. Congratulations ! You have deployed the sample application to OpenShift using Tekton. Day 1 of the workshop is now complete!","title":"5. Test it all out"},{"location":"exercise-5/","text":"Exercise 5: Customizing an existing Appsody Stack \u00b6 The goals for this day are to customize each of the pre-configured asset from Day 1, meaning we will: extend an Appsody Stack publish a new Collections add a new Tekton task to our Tekton pipeline Specifically, when you have completed this exercise, you will understand how to: extend an Appsody stack to create a new asset to be used in our Collection Prerequisites \u00b6 You should have already carried out the prerequisites defined in the Pre-work . Check that you have access to the Appsody CLI by typing (the exact version number my be greater than shown below): NOTE: In the exercises that follow you will see the actual command to run, followed by a separate example of running the command with the expected output. You only need to run the first example and never need to run a command you see preceded by a \"$\". You can even use the copy button on the right side of the command to make copying easier. appsody version You should see output similar to the following: $ appsody version appsody 0 .5.3 Steps \u00b6 The role of a stack in the development process Stack structure Create a new stack, based on an existing one Use the new stack in our example application 1. The role of a stack in the development process \u00b6 Developers use stacks to simplify building applications that require a specific set of technologies or development patterns. While there are numerous publicly available stacks to choose from, many enterprises want to build their own set of stacks that uphold their specific requirements and standards for how they want to their developers to build cloud native applications. In this exercise, you will learn how to modify an existing stack to more closely match your requirements. Before starting this, let's do a quick review of the design requirements for stacks. A stack is designed to support the developer in either a rapid, local development mode or a build-and-deploy mode. Rapid, local development mode \u00b6 In this mode, the stack contains everything a developer needs to build a new application on a local machine, with the application always running in a local containerized Docker environment. Introducing containerization from the start of the application development process (as opposed to development solely in the user space of the local machine) decreases the introduction of subtle errors in the containerization process and removes the need for a developer to install the core technology components of their application. In this mode, the stack is required to have all the dependencies for the specific technologies pre-built into the Docker image, and also to dynamically compliment these with whatever dependencies the developer adds explicitly for his or her code. Rapid local development mode in Appsody consists of the Appsody CLI (hooked into a local IDE if required) communicating with a local Docker container that is running the application under development. With this mode, application code can be held on the local file system, while being mounted in the Docker container, so that a local change can automatically trigger a restart of the application. Build-and-deploy mode \u00b6 In this mode, the stack enables the Appsody CLI to build a self-contained Docker image that includes both the core technologies in the stack plus the application code, along with the combined dependencies of both. You can deploy the resulting image manually or programmatically to any platform that supports Docker images (such as a local or public Kubernetes cluster). A pictorial view of how an application developer uses a stack, looks like this: The above development flow shows the manual deployment to a Kubernetes cluster. In more production-orientated environments, GitOps might trigger the build and deploy steps and Tekton Pipelines would drive the deployment. Collections , which are a part of Cloud Pak for Applications , bring together Appsody stacks, GitOps, and Tekton Pipelines to provide an enterprise-ready solution for cloud-native application development and deployment. We'll look at this in later exercises. 2. Stack structure \u00b6 Because a single Appsody stack can enable both rapid, local development and build-and-deploy modes, all stacks follow a standard structure. The structure below represents the source structure of a stack: my-stack \u251c\u2500\u2500 README.md \u251c\u2500\u2500 stack.yaml \u251c\u2500\u2500 image/ | \u251c\u2500\u2500 config/ | | \u2514\u2500\u2500 app-deploy.yaml | \u251c\u2500\u2500 project/ | | \u251c\u2500\u2500 [files that provide the technology components of the stack] | | \u2514\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 Dockerfile-stack | \u2514\u2500\u2500 LICENSE \u2514\u2500\u2500 templates/ \u251c\u2500\u2500 my-template-1/ | \u2514\u2500\u2500 [example files as a starter for the application, e.g. \"hello world\"] \u2514\u2500\u2500 my-template-2/ \u2514\u2500\u2500 [example files as a starter for a more complex application] As a Stack Architect you must create the above structure, build it into an actual stack image ready for use by an Application Developer who bases their new application on your stack. Part of your role as a stack architect is to include one of more sample applications (known as templates ) to help the application developer get started. Hence, when you build a stack, the structure above is processed and generates a Docker image for the stack, along with tar files of each of the templates, which can then all be stored and referenced in a local or public Appsody repo. The Appsody CLI can access the repo to use the stack to initiate local development. For this exercise we will modify the nodejs-express stack that we have been using for our quote-frontend, to add some additional security hardening (individual enterprises often have specific security standards that need to be met to allow deployment). NOTE : For future reference, to make your own stack from scratch, instead of extending an existing one, follow this tutorial . 3. Create a new stack, based on an existing one \u00b6 The goal of this step is to create a new Node.js Express stack by modifying the existing one. We'll copy it, build, and modify it. Initialize the stack \u00b6 To create a new stack, you must first construct a scaffold of the above structure. Stacks are classified as being stable , incubating or experimental . You can read more about these classifications here . To make things easy, the Appsody CLI supports an appsody stack create command to create a new stack, by copying an existing one. By running the appsody stack create command, nodejs-express stack will be copied and moved, a directory will be created containing the new stack. cd ~/appsody-apps appsody stack create my-nodejs-express --copy incubator/nodejs-express cd my-nodejs-express ls -al You should see output similar to the following: $ ls -la total 24 drwxr-xr-x 6 henrynash staff 192 8 Nov 11 :51 . drwxr-xr-x 5 henrynash staff 160 8 Nov 11 :51 .. -rw-r--r-- 1 henrynash staff 5026 8 Nov 11 :51 README.md drwxr-xr-x 7 henrynash staff 224 8 Nov 11 :51 image -rw-r--r-- 1 henrynash staff 319 8 Nov 11 :51 stack.yaml drwxr-xr-x 4 henrynash staff 128 8 Nov 11 :51 templates If you inspect the contents of the image directory, you will see how it matches the stack structure given earlier. Build your new stack \u00b6 Before we make any changes, let's go through the steps of building (or packaging ) a stack, to create a stack image (which is a Docker image) that the Appsody CLI can use to initiate a project using that stack. There is a Docker file ( Dockerfile-stack ) within the sample stack structure you copied. The appsody stack package command will use this to build the image. To build your new stack in this way, from the my-nodejs-express directory enter: appsody stack package This runs a Docker build, installs my-nodejs-express into a local Appsody repository (called dev.local ), and runs some basic tests to make sure the file is well formed. Once the build is complete, use the appsody list command to check that it is now available in the local repo: appsody list dev.local You should see output similar to the following: $ appsody list dev.local REPO ID VERSION TEMPLATES DESCRIPTION dev.local my-nodejs-express 0 .2.8 scaffold, *simple Express web framework for Node.js Run the new stack \u00b6 So, at this point, you have been carrying out your role as a stack architect to build and install your new (albeit unchanged) stack. Now it's time to try it out as an application developer. Create a new directory and initialize it with this new Appsody stack: mkdir ~/appsody-apps/test-my-stack cd ~/appsody-apps/test-my-stack appsody init dev.local/my-nodejs-express Now use appsody run to test running an application based on your copy of the stack: appsody run You should see output similar to the following: $ appsody run Running development environment... Using local cache for image dev.local/appsody/my-nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 9229 :9229 --name test73-dev -v /Users/henrynash/codewind-workspace/test73/:/project/user-app -v test73-deps:/project/user-app/node_modules -v /Users/henrynash/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller dev.local/appsody/my-nodejs-express:0.2 --mode = run [ Container ] Running APPSODY_PREP command: npm install --prefix user-app && npm audit fix --prefix user-app added 170 packages from 578 contributors and audited 295 packages in 3 .5s [ Container ] found 0 vulnerabilities ... [ Container ] App started on PORT 3000 To check it is running, in a separate terminal window we can use curl to hit the endpoint: curl -v localhost:3000 So now we are ready to make change to our new stack. For this exercise we will harden the HTTP headers that an application, built using this stack, responds with. We can look at the current headers returned: $ curl -v localhost:3000 * Trying 127 .0.0.1... * TCP_NODELAY set * Connected to localhost ( 127 .0.0.1 ) port 3000 ( #0) > GET / HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < X-Powered-By: Express < Content-Type: text/html ; charset = utf-8 < Content-Length: 19 < ETag: W/ \"13-0ErcqB22cNteJ3vXrBgUhlCj8os\" < Date: Mon, 21 Oct 2019 12 :09:49 GMT < Connection: keep-alive < * Connection #0 to host localhost left intact Hello from Appsody! Stop this current appsody run by running appsody stop in a separate terminal window, from within the same directory. For this exercise we will modify the stack to include the popular HTTP header security module helmet , and hence this should change the headers we see returned to us. Note we will do this as a stack architect since we don't want to rely on application developers remembering to do this. By doing this in the stack itself, all applications built using our modified stack will have helmet automatically enabled. Modify your custom stack \u00b6 When creating a custom stack, based on an existing stack, the first thing to do is to take a look at what the existing stack has provided. A more detailed description of the stack components can be found here , but the key ones are: A Dockerfile ( image/Dockerfile-stack ) that builds your stack image. This is what the appsody stack package command used above to build a Docker image of your stack - which is, if you like, the eventual artifact that you deliver as a stack architect to application developers. A Dockerfile ( image/project/Dockerfile ) that builds the final application image. This final image will contain both your stack and their application, and this Dockerfile is processed by the application developer running appsody build and appsody deploy . Typically some kind of server side code that is enabling the application the developer will create and run. For this stack, this is image/project/server.js . Some kind of dependency management, ensuring both the correct inclusion of components defined by the stack, as well as, potentially, any added by the application developer. For this stack, this is image/project/package.json . At least one sample application (or template ); these are stored in the templates directory. It is worth taking some time checking out the files given above to get a feel of the stack. For some stack modifications, you can actually use a form of stack inheritance - i.e. by using the existing stack images as the FROM image in Dockerfile-stack . An example of this might be where you just want to change one of the Dockerfile variables. In general, however, most modified stacks are effectively copies of an existing stack, with the additional changes added to gain the new, required functionality. Having examined the files above, you might have already spotted what we need to do to incorporate helmet into the new stack - namely to modify image/project/server.js to enable it. Go back to the my-nodejs-express directory. cd ~/appsody-apps/my-nodejs-express The current code in image/project/server.js looks something like this: // Requires statements and code for non-production mode usage if ( ! process . env . NODE_ENV || ! process . env . NODE_ENV === 'production' ) { require ( 'appmetrics-dash' ). attach (); } const express = require ( 'express' ); const health = require ( '@cloudnative/health-connect' ); const fs = require ( 'fs' ); require ( 'appmetrics-prometheus' ). attach (); const app = express (); const basePath = __dirname + '/user-app/' ; function getEntryPoint () { let rawPackage = fs . readFileSync ( basePath + 'package.json' ); let package = JSON . parse ( rawPackage ); if ( ! package . main ) { console . error ( \"Please define a primary entrypoint of your application by adding 'main: <entrypoint>' to package.json.\" ) process . exit ( 1 ) } return package . main ; } // Register the users app. As this is before the health/live/ready routes, // those can be overridden by the user const userApp = require ( basePath + getEntryPoint ()). app ; app . use ( '/' , userApp ); const healthcheck = new health . HealthChecker (); app . use ( '/live' , health . LivenessEndpoint ( healthcheck )); app . use ( '/ready' , health . ReadinessEndpoint ( healthcheck )); app . use ( '/health' , health . HealthEndpoint ( healthcheck )); app . get ( '*' , ( req , res ) => { res . status ( 404 ). send ( \"Not Found\" ); }); const PORT = process . env . PORT || 3000 ; const server = app . listen ( PORT , () => { console . log ( `App started on PORT ${ PORT } ` ); }); // Export server for testing purposes module . exports . server = server ; module . exports . PORT = PORT ; We will modify this file by adding two lines, to import helmet (with require() ), and to enable it with app.use() : // Requires statements and code for non-production mode usage if ( ! process . env . NODE_ENV || ! process . env . NODE_ENV === 'production' ) { require ( 'appmetrics-dash' ). attach (); } const express = require ( 'express' ); const helmet = require ( 'helmet' ); const health = require ( '@cloudnative/health-connect' ); const fs = require ( 'fs' ); require ( 'appmetrics-prometheus' ). attach (); const app = express (); app . use ( helmet ()); const basePath = __dirname + '/user-app/' ; ... Since we have added a new module that is required, we must also update the dependency management (package.json), to ensure this is pulled in: { ... \"dependencies\" : { \"@cloudnative/health-connect\" : \"^2.0.0\" , \"appmetrics-prometheus\" : \"^3.0.0\" , \"express\" : \"~4.16.0\" , \"helmet\" : \"^3.21.1\" }, ... } Now that we have modified our stack, we need to re-package it, using the same command as before: appsody stack package NOTE The appsody run command should pull down the latest packaged version, but in case this doesn't work, delete the directory and re-initialize. cd ~/appsody-apps rm -rf test-my-stack mkdir test-my-stack cd test-my-stack appsody init dev.local/my-nodejs-express This will have updated the dev.local index, so we can again go and run our application: appsody run If we now hit the endpoint as before with curl in verbose mode, we can see if the HTTP headers have changed: curl -v localhost:3000 You should now see security related headers like X-DNS-Prefetch-Control , Strict-Transport-Security , and X-Download-Options : $ curl -v localhost:3000 * Trying 127 .0.0.1... * TCP_NODELAY set * Connected to localhost ( 127 .0.0.1 ) port 3000 ( #0) > GET / HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < X-DNS-Prefetch-Control: off < X-Frame-Options: SAMEORIGIN < Strict-Transport-Security: max-age = 15552000 ; includeSubDomains < X-Download-Options: noopen < X-Content-Type-Options: nosniff < X-XSS-Protection: 1 ; mode = block < X-Powered-By: Express < Content-Type: text/html ; charset = utf-8 < Content-Length: 19 < ETag: W/ \"13-0ErcqB22cNteJ3vXrBgUhlCj8os\" < Date: Fri, 08 Nov 2019 19 :39:22 GMT < Connection: keep-alive < * Connection #0 to host localhost left intact Hello from Appsody!* As you should see, because the stack now incorporates helmet, the HTTP headers have changes, and our application runs with this protection. The inclusion of helmet is just an example of some of the security hardening you might want to take within your own enterprise. Stop this current appsody run by running appsody stop in a separate terminal window, from within the same directory. 4. Use the new stack in our example application \u00b6 A final step is to switch the actual quote-frontend application we built in Exercise 2 to use our new stack (rather than the original nodejs-express stack). The formal way of doing this is to repeat the steps from Exercise 2, where the new project is initialized (using our new stack), and the dependencies and code for the frontend are copied into the new project directory. However, in this case, where we have not changed anything that is actually placed directly in the project directory, we can take a short cut and just update the project to point at our new stack. This also gives you a bit more of an idea as to how an application project is linked to a stack. In the quote-frontend directory you created in Exercise 2, you should see a file called .appsody-config.yaml , which was created by the appsody init step. cd ~/appsody-apps/quote-frontend ls -la You should see output similar to the following: $ ls -al total 192 drwxr-xr-x 16 henrynash staff 512 15 Oct 12 :42 . drwxr-xr-x+ 85 henrynash staff 2720 17 Oct 21 :37 .. -rw-r--r-- 1 henrynash staff 64 19 Oct 11 :10 .appsody-config.yaml -rw-r--r-- 1 henrynash staff 1316 15 Oct 11 :12 .gitignore drwxr-xr-x 4 henrynash staff 128 15 Oct 11 :12 .vscode -rw-rw-r-- 1 henrynash staff 806 15 Oct 12 :50 app-deploy.yaml -rw-r--r-- 1 henrynash staff 290 15 Oct 11 :15 app.js drwxr-xr-x 4 henrynash staff 128 15 Oct 11 :15 config drwxr-xr-x 2 henrynash staff 64 15 Oct 11 :16 node_modules -rw-r--r-- 1 henrynash staff 0 15 Oct 11 :19 nodejs_dc.log -rw-r--r-- 1 henrynash staff 0 15 Oct 11 :19 nodejs_restclient.log -rw-r--r--@ 1 henrynash staff 73319 15 Oct 11 :16 package-lock.json -rw-r--r-- 1 henrynash staff 615 15 Oct 11 :15 package.json -rw-r--r-- 1 henrynash staff 2779 15 Oct 11 :15 quote.js drwxr-xr-x 3 henrynash staff 96 15 Oct 11 :12 test drwxr-xr-x 3 henrynash staff 96 15 Oct 11 :15 views Inspecting that file, reveals that it contains a pointer to the stack: cat .appsody-config.yaml Should output a configuration that uses nodejs-express : project-name: quote-frontend stack: kabanero/nodejs-express:0.2 We can simply change the second line to, instead, point to our new stack, i.e.: NOTE : When using a stack that is in development, it will carry semantic versioning derived from the original copied stack in addition to a latest tag. project-name: quote-frontend stack: dev.local/appsody/my-nodejs-express:latest Now re-run the frontend with appsody run : appsody run It should use our new stack: $ appsody run Running development environment... Using local cache for image dev.local/appsody/my-nodejs-express:latest ... [ Container ] App started on PORT 3000 We can confirm that our new HTTP protection is being used by, instead of using a browser, again using curl in verbose mode to hit the published endpoint: curl -v localhost:3000 You should see output similar to the following: $ curl -v localhost:3000 * Trying 127 .0.0.1... * TCP_NODELAY set * Connected to localhost ( 127 .0.0.1 ) port 3000 ( #0) > GET / HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 302 Found < X-DNS-Prefetch-Control: off < X-Frame-Options: SAMEORIGIN < Strict-Transport-Security: max-age = 15552000 ; includeSubDomains < X-Download-Options: noopen < X-Content-Type-Options: nosniff < X-XSS-Protection: 1 ; mode = block < X-Powered-By: Express < Location: /quote < Vary: Accept < Content-Type: text/plain ; charset = utf-8 < Content-Length: 28 < Date: Fri, 08 Nov 2019 19 :51:50 GMT < Connection: keep-alive < * Connection #0 to host localhost left intact Found. Redirecting to /quote We can tell our sample application is now using the new stack because it includes the new security related headers. Stop this current appsody run by running appsody stop in a separate terminal window, from within the same directory. Congratulations ! We have successfully built and tested out our modified stack - and seen how applications built against this stack automatically gain the (new) features it provides (without the application developer having to do anything themselves). In later exercises, we will discover how to publish this stack for other developers to utilize to build their own applications.","title":"Lab 5. Customize an existing Appsody Stack"},{"location":"exercise-5/#exercise-5-customizing-an-existing-appsody-stack","text":"The goals for this day are to customize each of the pre-configured asset from Day 1, meaning we will: extend an Appsody Stack publish a new Collections add a new Tekton task to our Tekton pipeline Specifically, when you have completed this exercise, you will understand how to: extend an Appsody stack to create a new asset to be used in our Collection","title":"Exercise 5: Customizing an existing Appsody Stack"},{"location":"exercise-5/#prerequisites","text":"You should have already carried out the prerequisites defined in the Pre-work . Check that you have access to the Appsody CLI by typing (the exact version number my be greater than shown below): NOTE: In the exercises that follow you will see the actual command to run, followed by a separate example of running the command with the expected output. You only need to run the first example and never need to run a command you see preceded by a \"$\". You can even use the copy button on the right side of the command to make copying easier. appsody version You should see output similar to the following: $ appsody version appsody 0 .5.3","title":"Prerequisites"},{"location":"exercise-5/#steps","text":"The role of a stack in the development process Stack structure Create a new stack, based on an existing one Use the new stack in our example application","title":"Steps"},{"location":"exercise-5/#1-the-role-of-a-stack-in-the-development-process","text":"Developers use stacks to simplify building applications that require a specific set of technologies or development patterns. While there are numerous publicly available stacks to choose from, many enterprises want to build their own set of stacks that uphold their specific requirements and standards for how they want to their developers to build cloud native applications. In this exercise, you will learn how to modify an existing stack to more closely match your requirements. Before starting this, let's do a quick review of the design requirements for stacks. A stack is designed to support the developer in either a rapid, local development mode or a build-and-deploy mode.","title":"1. The role of a stack in the development process"},{"location":"exercise-5/#rapid-local-development-mode","text":"In this mode, the stack contains everything a developer needs to build a new application on a local machine, with the application always running in a local containerized Docker environment. Introducing containerization from the start of the application development process (as opposed to development solely in the user space of the local machine) decreases the introduction of subtle errors in the containerization process and removes the need for a developer to install the core technology components of their application. In this mode, the stack is required to have all the dependencies for the specific technologies pre-built into the Docker image, and also to dynamically compliment these with whatever dependencies the developer adds explicitly for his or her code. Rapid local development mode in Appsody consists of the Appsody CLI (hooked into a local IDE if required) communicating with a local Docker container that is running the application under development. With this mode, application code can be held on the local file system, while being mounted in the Docker container, so that a local change can automatically trigger a restart of the application.","title":"Rapid, local development mode"},{"location":"exercise-5/#build-and-deploy-mode","text":"In this mode, the stack enables the Appsody CLI to build a self-contained Docker image that includes both the core technologies in the stack plus the application code, along with the combined dependencies of both. You can deploy the resulting image manually or programmatically to any platform that supports Docker images (such as a local or public Kubernetes cluster). A pictorial view of how an application developer uses a stack, looks like this: The above development flow shows the manual deployment to a Kubernetes cluster. In more production-orientated environments, GitOps might trigger the build and deploy steps and Tekton Pipelines would drive the deployment. Collections , which are a part of Cloud Pak for Applications , bring together Appsody stacks, GitOps, and Tekton Pipelines to provide an enterprise-ready solution for cloud-native application development and deployment. We'll look at this in later exercises.","title":"Build-and-deploy mode"},{"location":"exercise-5/#2-stack-structure","text":"Because a single Appsody stack can enable both rapid, local development and build-and-deploy modes, all stacks follow a standard structure. The structure below represents the source structure of a stack: my-stack \u251c\u2500\u2500 README.md \u251c\u2500\u2500 stack.yaml \u251c\u2500\u2500 image/ | \u251c\u2500\u2500 config/ | | \u2514\u2500\u2500 app-deploy.yaml | \u251c\u2500\u2500 project/ | | \u251c\u2500\u2500 [files that provide the technology components of the stack] | | \u2514\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 Dockerfile-stack | \u2514\u2500\u2500 LICENSE \u2514\u2500\u2500 templates/ \u251c\u2500\u2500 my-template-1/ | \u2514\u2500\u2500 [example files as a starter for the application, e.g. \"hello world\"] \u2514\u2500\u2500 my-template-2/ \u2514\u2500\u2500 [example files as a starter for a more complex application] As a Stack Architect you must create the above structure, build it into an actual stack image ready for use by an Application Developer who bases their new application on your stack. Part of your role as a stack architect is to include one of more sample applications (known as templates ) to help the application developer get started. Hence, when you build a stack, the structure above is processed and generates a Docker image for the stack, along with tar files of each of the templates, which can then all be stored and referenced in a local or public Appsody repo. The Appsody CLI can access the repo to use the stack to initiate local development. For this exercise we will modify the nodejs-express stack that we have been using for our quote-frontend, to add some additional security hardening (individual enterprises often have specific security standards that need to be met to allow deployment). NOTE : For future reference, to make your own stack from scratch, instead of extending an existing one, follow this tutorial .","title":"2. Stack structure"},{"location":"exercise-5/#3-create-a-new-stack-based-on-an-existing-one","text":"The goal of this step is to create a new Node.js Express stack by modifying the existing one. We'll copy it, build, and modify it.","title":"3. Create a new stack, based on an existing one"},{"location":"exercise-5/#initialize-the-stack","text":"To create a new stack, you must first construct a scaffold of the above structure. Stacks are classified as being stable , incubating or experimental . You can read more about these classifications here . To make things easy, the Appsody CLI supports an appsody stack create command to create a new stack, by copying an existing one. By running the appsody stack create command, nodejs-express stack will be copied and moved, a directory will be created containing the new stack. cd ~/appsody-apps appsody stack create my-nodejs-express --copy incubator/nodejs-express cd my-nodejs-express ls -al You should see output similar to the following: $ ls -la total 24 drwxr-xr-x 6 henrynash staff 192 8 Nov 11 :51 . drwxr-xr-x 5 henrynash staff 160 8 Nov 11 :51 .. -rw-r--r-- 1 henrynash staff 5026 8 Nov 11 :51 README.md drwxr-xr-x 7 henrynash staff 224 8 Nov 11 :51 image -rw-r--r-- 1 henrynash staff 319 8 Nov 11 :51 stack.yaml drwxr-xr-x 4 henrynash staff 128 8 Nov 11 :51 templates If you inspect the contents of the image directory, you will see how it matches the stack structure given earlier.","title":"Initialize the stack"},{"location":"exercise-5/#build-your-new-stack","text":"Before we make any changes, let's go through the steps of building (or packaging ) a stack, to create a stack image (which is a Docker image) that the Appsody CLI can use to initiate a project using that stack. There is a Docker file ( Dockerfile-stack ) within the sample stack structure you copied. The appsody stack package command will use this to build the image. To build your new stack in this way, from the my-nodejs-express directory enter: appsody stack package This runs a Docker build, installs my-nodejs-express into a local Appsody repository (called dev.local ), and runs some basic tests to make sure the file is well formed. Once the build is complete, use the appsody list command to check that it is now available in the local repo: appsody list dev.local You should see output similar to the following: $ appsody list dev.local REPO ID VERSION TEMPLATES DESCRIPTION dev.local my-nodejs-express 0 .2.8 scaffold, *simple Express web framework for Node.js","title":"Build your new stack"},{"location":"exercise-5/#run-the-new-stack","text":"So, at this point, you have been carrying out your role as a stack architect to build and install your new (albeit unchanged) stack. Now it's time to try it out as an application developer. Create a new directory and initialize it with this new Appsody stack: mkdir ~/appsody-apps/test-my-stack cd ~/appsody-apps/test-my-stack appsody init dev.local/my-nodejs-express Now use appsody run to test running an application based on your copy of the stack: appsody run You should see output similar to the following: $ appsody run Running development environment... Using local cache for image dev.local/appsody/my-nodejs-express:0.2 Running docker command: docker run --rm -p 3000 :3000 -p 9229 :9229 --name test73-dev -v /Users/henrynash/codewind-workspace/test73/:/project/user-app -v test73-deps:/project/user-app/node_modules -v /Users/henrynash/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller dev.local/appsody/my-nodejs-express:0.2 --mode = run [ Container ] Running APPSODY_PREP command: npm install --prefix user-app && npm audit fix --prefix user-app added 170 packages from 578 contributors and audited 295 packages in 3 .5s [ Container ] found 0 vulnerabilities ... [ Container ] App started on PORT 3000 To check it is running, in a separate terminal window we can use curl to hit the endpoint: curl -v localhost:3000 So now we are ready to make change to our new stack. For this exercise we will harden the HTTP headers that an application, built using this stack, responds with. We can look at the current headers returned: $ curl -v localhost:3000 * Trying 127 .0.0.1... * TCP_NODELAY set * Connected to localhost ( 127 .0.0.1 ) port 3000 ( #0) > GET / HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < X-Powered-By: Express < Content-Type: text/html ; charset = utf-8 < Content-Length: 19 < ETag: W/ \"13-0ErcqB22cNteJ3vXrBgUhlCj8os\" < Date: Mon, 21 Oct 2019 12 :09:49 GMT < Connection: keep-alive < * Connection #0 to host localhost left intact Hello from Appsody! Stop this current appsody run by running appsody stop in a separate terminal window, from within the same directory. For this exercise we will modify the stack to include the popular HTTP header security module helmet , and hence this should change the headers we see returned to us. Note we will do this as a stack architect since we don't want to rely on application developers remembering to do this. By doing this in the stack itself, all applications built using our modified stack will have helmet automatically enabled.","title":"Run the new stack"},{"location":"exercise-5/#modify-your-custom-stack","text":"When creating a custom stack, based on an existing stack, the first thing to do is to take a look at what the existing stack has provided. A more detailed description of the stack components can be found here , but the key ones are: A Dockerfile ( image/Dockerfile-stack ) that builds your stack image. This is what the appsody stack package command used above to build a Docker image of your stack - which is, if you like, the eventual artifact that you deliver as a stack architect to application developers. A Dockerfile ( image/project/Dockerfile ) that builds the final application image. This final image will contain both your stack and their application, and this Dockerfile is processed by the application developer running appsody build and appsody deploy . Typically some kind of server side code that is enabling the application the developer will create and run. For this stack, this is image/project/server.js . Some kind of dependency management, ensuring both the correct inclusion of components defined by the stack, as well as, potentially, any added by the application developer. For this stack, this is image/project/package.json . At least one sample application (or template ); these are stored in the templates directory. It is worth taking some time checking out the files given above to get a feel of the stack. For some stack modifications, you can actually use a form of stack inheritance - i.e. by using the existing stack images as the FROM image in Dockerfile-stack . An example of this might be where you just want to change one of the Dockerfile variables. In general, however, most modified stacks are effectively copies of an existing stack, with the additional changes added to gain the new, required functionality. Having examined the files above, you might have already spotted what we need to do to incorporate helmet into the new stack - namely to modify image/project/server.js to enable it. Go back to the my-nodejs-express directory. cd ~/appsody-apps/my-nodejs-express The current code in image/project/server.js looks something like this: // Requires statements and code for non-production mode usage if ( ! process . env . NODE_ENV || ! process . env . NODE_ENV === 'production' ) { require ( 'appmetrics-dash' ). attach (); } const express = require ( 'express' ); const health = require ( '@cloudnative/health-connect' ); const fs = require ( 'fs' ); require ( 'appmetrics-prometheus' ). attach (); const app = express (); const basePath = __dirname + '/user-app/' ; function getEntryPoint () { let rawPackage = fs . readFileSync ( basePath + 'package.json' ); let package = JSON . parse ( rawPackage ); if ( ! package . main ) { console . error ( \"Please define a primary entrypoint of your application by adding 'main: <entrypoint>' to package.json.\" ) process . exit ( 1 ) } return package . main ; } // Register the users app. As this is before the health/live/ready routes, // those can be overridden by the user const userApp = require ( basePath + getEntryPoint ()). app ; app . use ( '/' , userApp ); const healthcheck = new health . HealthChecker (); app . use ( '/live' , health . LivenessEndpoint ( healthcheck )); app . use ( '/ready' , health . ReadinessEndpoint ( healthcheck )); app . use ( '/health' , health . HealthEndpoint ( healthcheck )); app . get ( '*' , ( req , res ) => { res . status ( 404 ). send ( \"Not Found\" ); }); const PORT = process . env . PORT || 3000 ; const server = app . listen ( PORT , () => { console . log ( `App started on PORT ${ PORT } ` ); }); // Export server for testing purposes module . exports . server = server ; module . exports . PORT = PORT ; We will modify this file by adding two lines, to import helmet (with require() ), and to enable it with app.use() : // Requires statements and code for non-production mode usage if ( ! process . env . NODE_ENV || ! process . env . NODE_ENV === 'production' ) { require ( 'appmetrics-dash' ). attach (); } const express = require ( 'express' ); const helmet = require ( 'helmet' ); const health = require ( '@cloudnative/health-connect' ); const fs = require ( 'fs' ); require ( 'appmetrics-prometheus' ). attach (); const app = express (); app . use ( helmet ()); const basePath = __dirname + '/user-app/' ; ... Since we have added a new module that is required, we must also update the dependency management (package.json), to ensure this is pulled in: { ... \"dependencies\" : { \"@cloudnative/health-connect\" : \"^2.0.0\" , \"appmetrics-prometheus\" : \"^3.0.0\" , \"express\" : \"~4.16.0\" , \"helmet\" : \"^3.21.1\" }, ... } Now that we have modified our stack, we need to re-package it, using the same command as before: appsody stack package NOTE The appsody run command should pull down the latest packaged version, but in case this doesn't work, delete the directory and re-initialize. cd ~/appsody-apps rm -rf test-my-stack mkdir test-my-stack cd test-my-stack appsody init dev.local/my-nodejs-express This will have updated the dev.local index, so we can again go and run our application: appsody run If we now hit the endpoint as before with curl in verbose mode, we can see if the HTTP headers have changed: curl -v localhost:3000 You should now see security related headers like X-DNS-Prefetch-Control , Strict-Transport-Security , and X-Download-Options : $ curl -v localhost:3000 * Trying 127 .0.0.1... * TCP_NODELAY set * Connected to localhost ( 127 .0.0.1 ) port 3000 ( #0) > GET / HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 200 OK < X-DNS-Prefetch-Control: off < X-Frame-Options: SAMEORIGIN < Strict-Transport-Security: max-age = 15552000 ; includeSubDomains < X-Download-Options: noopen < X-Content-Type-Options: nosniff < X-XSS-Protection: 1 ; mode = block < X-Powered-By: Express < Content-Type: text/html ; charset = utf-8 < Content-Length: 19 < ETag: W/ \"13-0ErcqB22cNteJ3vXrBgUhlCj8os\" < Date: Fri, 08 Nov 2019 19 :39:22 GMT < Connection: keep-alive < * Connection #0 to host localhost left intact Hello from Appsody!* As you should see, because the stack now incorporates helmet, the HTTP headers have changes, and our application runs with this protection. The inclusion of helmet is just an example of some of the security hardening you might want to take within your own enterprise. Stop this current appsody run by running appsody stop in a separate terminal window, from within the same directory.","title":"Modify your custom stack"},{"location":"exercise-5/#4-use-the-new-stack-in-our-example-application","text":"A final step is to switch the actual quote-frontend application we built in Exercise 2 to use our new stack (rather than the original nodejs-express stack). The formal way of doing this is to repeat the steps from Exercise 2, where the new project is initialized (using our new stack), and the dependencies and code for the frontend are copied into the new project directory. However, in this case, where we have not changed anything that is actually placed directly in the project directory, we can take a short cut and just update the project to point at our new stack. This also gives you a bit more of an idea as to how an application project is linked to a stack. In the quote-frontend directory you created in Exercise 2, you should see a file called .appsody-config.yaml , which was created by the appsody init step. cd ~/appsody-apps/quote-frontend ls -la You should see output similar to the following: $ ls -al total 192 drwxr-xr-x 16 henrynash staff 512 15 Oct 12 :42 . drwxr-xr-x+ 85 henrynash staff 2720 17 Oct 21 :37 .. -rw-r--r-- 1 henrynash staff 64 19 Oct 11 :10 .appsody-config.yaml -rw-r--r-- 1 henrynash staff 1316 15 Oct 11 :12 .gitignore drwxr-xr-x 4 henrynash staff 128 15 Oct 11 :12 .vscode -rw-rw-r-- 1 henrynash staff 806 15 Oct 12 :50 app-deploy.yaml -rw-r--r-- 1 henrynash staff 290 15 Oct 11 :15 app.js drwxr-xr-x 4 henrynash staff 128 15 Oct 11 :15 config drwxr-xr-x 2 henrynash staff 64 15 Oct 11 :16 node_modules -rw-r--r-- 1 henrynash staff 0 15 Oct 11 :19 nodejs_dc.log -rw-r--r-- 1 henrynash staff 0 15 Oct 11 :19 nodejs_restclient.log -rw-r--r--@ 1 henrynash staff 73319 15 Oct 11 :16 package-lock.json -rw-r--r-- 1 henrynash staff 615 15 Oct 11 :15 package.json -rw-r--r-- 1 henrynash staff 2779 15 Oct 11 :15 quote.js drwxr-xr-x 3 henrynash staff 96 15 Oct 11 :12 test drwxr-xr-x 3 henrynash staff 96 15 Oct 11 :15 views Inspecting that file, reveals that it contains a pointer to the stack: cat .appsody-config.yaml Should output a configuration that uses nodejs-express : project-name: quote-frontend stack: kabanero/nodejs-express:0.2 We can simply change the second line to, instead, point to our new stack, i.e.: NOTE : When using a stack that is in development, it will carry semantic versioning derived from the original copied stack in addition to a latest tag. project-name: quote-frontend stack: dev.local/appsody/my-nodejs-express:latest Now re-run the frontend with appsody run : appsody run It should use our new stack: $ appsody run Running development environment... Using local cache for image dev.local/appsody/my-nodejs-express:latest ... [ Container ] App started on PORT 3000 We can confirm that our new HTTP protection is being used by, instead of using a browser, again using curl in verbose mode to hit the published endpoint: curl -v localhost:3000 You should see output similar to the following: $ curl -v localhost:3000 * Trying 127 .0.0.1... * TCP_NODELAY set * Connected to localhost ( 127 .0.0.1 ) port 3000 ( #0) > GET / HTTP/1.1 > Host: localhost:3000 > User-Agent: curl/7.64.1 > Accept: */* > < HTTP/1.1 302 Found < X-DNS-Prefetch-Control: off < X-Frame-Options: SAMEORIGIN < Strict-Transport-Security: max-age = 15552000 ; includeSubDomains < X-Download-Options: noopen < X-Content-Type-Options: nosniff < X-XSS-Protection: 1 ; mode = block < X-Powered-By: Express < Location: /quote < Vary: Accept < Content-Type: text/plain ; charset = utf-8 < Content-Length: 28 < Date: Fri, 08 Nov 2019 19 :51:50 GMT < Connection: keep-alive < * Connection #0 to host localhost left intact Found. Redirecting to /quote We can tell our sample application is now using the new stack because it includes the new security related headers. Stop this current appsody run by running appsody stop in a separate terminal window, from within the same directory. Congratulations ! We have successfully built and tested out our modified stack - and seen how applications built against this stack automatically gain the (new) features it provides (without the application developer having to do anything themselves). In later exercises, we will discover how to publish this stack for other developers to utilize to build their own applications.","title":"4. Use the new stack in our example application"},{"location":"exercise-6/","text":"Exercise 6: Building a custom Appsody Stack Collection in Kabanero \u00b6 In this exercise, we will show how to create a custom Collection, that includes the custom Appsody Stack from the previous exercise. When you have completed this exercise, you will understand how to clone and host your own Collection modify the Collection to include a custom Appsody Stack Prerequisites \u00b6 You should have already carried out the prerequisites defined in Exercise 5 . In addition, you need to ensure you have the following installed on your local machine: yq python3 pyYAML On macOS, you can install the above with: brew install yq brew install python pip install pyYAML NOTE: do not install the python yq package, it has a different syntax than the yq application and will cause the build scripts to fail. About custom Kabanero Repositories \u00b6 By default the Kabanero open source project is configured to automatically use the latest release at https://github.com/kabanero-io/collections . The default collections can be modified to meet an organization's unique needs. Collections are categorized as either stable , incubator or experimental depending on the content of the collection. stable : collections that meet a set of technical requirements. incubator : collections that are actively being worked on to satisfy the stable criteria. experimental : collections that are used for trying out specific capabilities or proof of concept work. Collections include an Appsody stack, and a Tekton pipeline. Steps \u00b6 Create a new repo to host your custom collection Create a new image namespace to host images on OpenShift Set up a local build environment Add our custom stack to the new collection Build the new collection Push collection images Update code repo and release a new collection 1. Create a new repo to host your custom collection \u00b6 Go to https://github.com/new and create a new repository, collections . Do not initiatize the repos with a license file or README. Clone the default collections repository and create a new copy of it in your GitHub organization, replacing <username> with your own. cd ~/appsody-apps/ git clone https://github.com/kabanero-io/collections cd collections git checkout tags/0.2.1 -b 0 .2.1-custom git remote add my-org https://github.com/<username>/collections.git git push -u my-org About the Kabanero Repo structure \u00b6 ci \u251c\u2500\u2500 [ files used for CI/CD of the Collections ] experimental (or incubator, or stable) \u251c\u2500\u2500 common/ | \u251c\u2500\u2500 pipelines/ | | \u251c\u2500\u2500 common-pipeline-1/ | | | \u2514\u2500\u2500 [pipeline files that make up a full tekton pipeline used with all collections in experimental category] | | \u2514\u2500\u2500 common-pipeline-n/ | | \u2514\u2500\u2500 [pipeline files that make up a full tekton pipeline used with all collections in experimental category] \u251c\u2500\u2500 collection-1/ | \u251c\u2500\u2500 [collection files - see collection structure below] \u2514\u2500\u2500 collection-n/ \u2514\u2500\u2500 [collection files - see collection structure below] 2. Create a new image namespace to host images on OpenShift \u00b6 To actually use the stacks we need images, images will be hosted on openshift oc new-project kabanero-noauth oc policy add-role-to-group registry-viewer system:unauthenticated -n kabanero-noauth NOTE: You may seem a warning about this step, but it should still have worked, e.g. oc new-project kabanero-noauth oc policy add-role-to-group registry-viewer system:unauthenticated -n kabanero-noauth Warning: Group 'system:unauthenticated' not found role \"registry-viewer\" added: \"system:unauthenticated\" 3. Set up a local build environment \u00b6 There are several environment variables that need to be set up. These are required in order to correctly build the collections. NOTE: When setting the TRAVIS_REPO_SLUG variable, make sure you substitute the actual github repo you created above in place of <username> . export IMAGE_REGISTRY_ORG = kabanero-noauth export IMAGE_REGISTRY_PUBLISH = true export IMAGE_REGISTRY_USERNAME = $( oc whoami ) export IMAGE_REGISTRY_PASSWORD = $( oc whoami -t ) export TRAVIS_REPO_SLUG = <username>/collections export TRAVIS_TAG = 0 .2.1-custom In addition to the above, the IMAGE_REGISTRY environment variable should still be set from Exercise 3 , which you can check with: echo $IMAGE_REGISTRY $ echo $IMAGE_REGISTRY IMAGE_REGISTRY = docker-registry-default.henrycluster6-5290c8c8e5797924dc1ad5d1b85b37c0-0001.eu-gb.containers.appdomain.cloud If IMAGE_REGISTRY is not set, then you need to set it up again, as described in Exercise 3 - Access the internal docker registry 4. Add our custom stack to the new collection \u00b6 Now we take our custom stack from exercise 5 (recall that is was named my-nodejs-express and includes the helmet library) and copy it over to the incubator folder of our collection repo. From the collections repo, perform the following steps: List the collections before the copy: ls incubator common java-spring-boot2 nodejs-express java-microprofile nodejs nodejs-loopback Now copy in our new custom stack: cp -R ~/appsody-apps/my-nodejs-express incubator Check that we now have this in the list of collections: ls incubator common java-spring-boot2 nodejs nodejs-loopback java-microprofile my-nodejs-express nodejs-express triggers Create a new file called collection.yaml in collections/incubator/my-nodejs-express , add the following: default-image : my-nodejs-express default-pipeline : default images : - id : my-nodejs-express image : $IMAGE_REGISTRY_ORG/my-nodejs-express:0.3 Edit the new file called stack.yaml in collections/incubator/my-nodejs-express . Update the name and description fields to add \"with Helmet\" and also replace the maintainer information with your information if desired (you will probably see a different version, don't change that and keep as-is): name : Node.js Express with Helmet version : 0.3.0 description : Express web framework for Node.js with Helmet license : Apache-2.0 language : nodejs maintainers : - name : Your Name email : your email github-id : yourgithubid default-template : simple And also create a directory called pipelines in collections/incubator/my-nodejs-express , and add a single empty file called .gitkeep . 5. Build the new collection \u00b6 This step builds the kabanero-index.yaml file. From the collections directory, run the build script. For example: cd ~/appsody-apps/collections IMAGE_REGISTRY_ORG = $IMAGE_REGISTRY / $IMAGE_REGISTRY_ORG ./ci/build.sh NOTE : This process can take several minutes to complete. Note that this will build all the collections in the incubator directory, including the new my-nodejs-express stack. Following the build, you can find the generated collection assets in the collections/ci/assets/ directory and all the docker images in your local docker registry. You should see output like the following, take note of the my-nodejs-express stack being built, and ensure there are no errors in the output: ... Listing all stacks Building stacks: incubator/java-microprofile incubator/java-spring-boot2 incubator/my-nodejs-express incubator/nodejs-express incubator/nodejs-loopback incubator/nodejs ... - BUILDING stack: incubator/my-nodejs-express File containing output from image build: /Users/stevemar/appsody-apps/collections/ci/build/image.my-nodejs-express.0.2.8.log created kabanero/my-nodejs-express:0.2.8 --- Created template archive: incubator.my-nodejs-express.v0.2.8.templates.scaffold.tar.gz --- Created template archive: incubator.my-nodejs-express.v0.2.8.templates.simple.tar.gz ... === Testing my-nodejs-express : scaffold ~/appsody-apps/collections/ci/build/test/kabanero-index-local/my-nodejs-express/scaffold ~/appsody-apps/collections > appsody init kabanero-index-local/my-nodejs-express scaffold > appsody run -P --name my-nodejs-express-scaffold ... > appsody stop --name my-nodejs-express-scaffold Stopping development environment Running command: docker stop my-nodejs-express-scaffold ... > appsody build error = 0 ~/appsody-apps/collections 6. Push collection images \u00b6 To push the collection images, there is a release script that will do the actual pushing to the image registry. The current scripts have a minor issue with private registry login and tagging so first log in to the private registry, and then run the release script. The two commands below will achieve this: echo $IMAGE_REGISTRY_PASSWORD | docker login -u $IMAGE_REGISTRY_USERNAME --password-stdin $IMAGE_REGISTRY IMAGE_REGISTRY = \"\" IMAGE_REGISTRY_PASSWORD = \"\" ./ci/release.sh You should see output like the following, take note of the my-nodejs-express stack being pushed to the registry, and ensure there are no errors in the output: $ IMAGE_REGISTRY = \"\" IMAGE_REGISTRY_PASSWORD = \"\" ./ci/release.sh == Running pre_env.d scripts == Done pre_env.d scripts == Running post_env.d scripts == Done post_env.d scripts ... Releasing: /Users/stevemar/appsody-apps/collections/ci/assets/incubator.my-nodejs-express.v0.2.8.templates.scaffold.tar.gz Releasing: /Users/stevemar/appsody-apps/collections/ci/assets/incubator.my-nodejs-express.v0.2.8.templates.simple.tar.gz ... Pushing docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express The push refers to repository [ docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express ] 535ab22146d1: Layer already exists 0 : digest: sha256:535ab22146d1 size: 3883 535ab22146d1: Layer already exists 0 .2: digest: sha256:535ab22146d1 size: 3883 535ab22146d1: Layer already exists 0 .2.8: digest: sha256:535ab22146d1 size: 3883 535ab22146d1: Layer already exists latest: digest: sha256:535ab22146d1 size: 3883 Tagging docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2.8 > docker tag kabanero-noauth/my-nodejs-express:0.2.8 docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2.8 ... NOTE: Since this above is pushing a lot of images, it is possible that you might see this command fail with a timeout error, or unknown blob. Retrying the command (more than once if necessary) will resolve this issue. 7. Update code repo and release a new collection \u00b6 Once you have made all the changes to the collection and you are ready to push the changes back to your git repository then # Add your custom stack changes git add -A # Create a commit message git commit -m \"Updates to the collections\" # Push the changes to your repository. For example: git push -u my-org To create a full release of the collections, create a git tag: git tag 0 .2.1-custom -m \"Custom collections, version 0.2.1-custom\" git push --tags Navigating back to your GitHub repo, you should see a new release available: Clicking on the release name (0.2.1-custom) will allow you to edit the release. Click on Edit tag . and then upload all the files in collections/ci/release/ which were generated from the previous steps, by clicking on the Attach binaries... box. Once you have uploaded the files you can publish your new collection by clicking Publish release , at the bottom of the page You will note that the collection includes the kabanero-index.yaml file we edited earlier. The url to this index file is is what you will provide appsody as a link to your new custom repository (that is contained within the new collection. You normally obtain and copy the url (depending on your browser) by right (or secondary) clicking over the kabanero-index.yaml item in the list of files shown in the release. It should be of the form: https://github.com/<username>/collections/releases/download/0.2.1-custom/kabanero-index.yaml You will need this url for the next exercise, where we will create an appsody application based on your new collection. Congratulations!! We've just created our own custom collection that included our own custom stack. Now we need to test our released collection using Appsody. On to the next exercise.","title":"Lab 6. Build a custom Collection repository"},{"location":"exercise-6/#exercise-6-building-a-custom-appsody-stack-collection-in-kabanero","text":"In this exercise, we will show how to create a custom Collection, that includes the custom Appsody Stack from the previous exercise. When you have completed this exercise, you will understand how to clone and host your own Collection modify the Collection to include a custom Appsody Stack","title":"Exercise 6: Building a custom Appsody Stack Collection in Kabanero"},{"location":"exercise-6/#prerequisites","text":"You should have already carried out the prerequisites defined in Exercise 5 . In addition, you need to ensure you have the following installed on your local machine: yq python3 pyYAML On macOS, you can install the above with: brew install yq brew install python pip install pyYAML NOTE: do not install the python yq package, it has a different syntax than the yq application and will cause the build scripts to fail.","title":"Prerequisites"},{"location":"exercise-6/#about-custom-kabanero-repositories","text":"By default the Kabanero open source project is configured to automatically use the latest release at https://github.com/kabanero-io/collections . The default collections can be modified to meet an organization's unique needs. Collections are categorized as either stable , incubator or experimental depending on the content of the collection. stable : collections that meet a set of technical requirements. incubator : collections that are actively being worked on to satisfy the stable criteria. experimental : collections that are used for trying out specific capabilities or proof of concept work. Collections include an Appsody stack, and a Tekton pipeline.","title":"About custom Kabanero Repositories"},{"location":"exercise-6/#steps","text":"Create a new repo to host your custom collection Create a new image namespace to host images on OpenShift Set up a local build environment Add our custom stack to the new collection Build the new collection Push collection images Update code repo and release a new collection","title":"Steps"},{"location":"exercise-6/#1-create-a-new-repo-to-host-your-custom-collection","text":"Go to https://github.com/new and create a new repository, collections . Do not initiatize the repos with a license file or README. Clone the default collections repository and create a new copy of it in your GitHub organization, replacing <username> with your own. cd ~/appsody-apps/ git clone https://github.com/kabanero-io/collections cd collections git checkout tags/0.2.1 -b 0 .2.1-custom git remote add my-org https://github.com/<username>/collections.git git push -u my-org","title":"1. Create a new repo to host your custom collection"},{"location":"exercise-6/#about-the-kabanero-repo-structure","text":"ci \u251c\u2500\u2500 [ files used for CI/CD of the Collections ] experimental (or incubator, or stable) \u251c\u2500\u2500 common/ | \u251c\u2500\u2500 pipelines/ | | \u251c\u2500\u2500 common-pipeline-1/ | | | \u2514\u2500\u2500 [pipeline files that make up a full tekton pipeline used with all collections in experimental category] | | \u2514\u2500\u2500 common-pipeline-n/ | | \u2514\u2500\u2500 [pipeline files that make up a full tekton pipeline used with all collections in experimental category] \u251c\u2500\u2500 collection-1/ | \u251c\u2500\u2500 [collection files - see collection structure below] \u2514\u2500\u2500 collection-n/ \u2514\u2500\u2500 [collection files - see collection structure below]","title":"About the Kabanero Repo structure"},{"location":"exercise-6/#2-create-a-new-image-namespace-to-host-images-on-openshift","text":"To actually use the stacks we need images, images will be hosted on openshift oc new-project kabanero-noauth oc policy add-role-to-group registry-viewer system:unauthenticated -n kabanero-noauth NOTE: You may seem a warning about this step, but it should still have worked, e.g. oc new-project kabanero-noauth oc policy add-role-to-group registry-viewer system:unauthenticated -n kabanero-noauth Warning: Group 'system:unauthenticated' not found role \"registry-viewer\" added: \"system:unauthenticated\"","title":"2. Create a new image namespace to host images on OpenShift"},{"location":"exercise-6/#3-set-up-a-local-build-environment","text":"There are several environment variables that need to be set up. These are required in order to correctly build the collections. NOTE: When setting the TRAVIS_REPO_SLUG variable, make sure you substitute the actual github repo you created above in place of <username> . export IMAGE_REGISTRY_ORG = kabanero-noauth export IMAGE_REGISTRY_PUBLISH = true export IMAGE_REGISTRY_USERNAME = $( oc whoami ) export IMAGE_REGISTRY_PASSWORD = $( oc whoami -t ) export TRAVIS_REPO_SLUG = <username>/collections export TRAVIS_TAG = 0 .2.1-custom In addition to the above, the IMAGE_REGISTRY environment variable should still be set from Exercise 3 , which you can check with: echo $IMAGE_REGISTRY $ echo $IMAGE_REGISTRY IMAGE_REGISTRY = docker-registry-default.henrycluster6-5290c8c8e5797924dc1ad5d1b85b37c0-0001.eu-gb.containers.appdomain.cloud If IMAGE_REGISTRY is not set, then you need to set it up again, as described in Exercise 3 - Access the internal docker registry","title":"3. Set up a local build environment"},{"location":"exercise-6/#4-add-our-custom-stack-to-the-new-collection","text":"Now we take our custom stack from exercise 5 (recall that is was named my-nodejs-express and includes the helmet library) and copy it over to the incubator folder of our collection repo. From the collections repo, perform the following steps: List the collections before the copy: ls incubator common java-spring-boot2 nodejs-express java-microprofile nodejs nodejs-loopback Now copy in our new custom stack: cp -R ~/appsody-apps/my-nodejs-express incubator Check that we now have this in the list of collections: ls incubator common java-spring-boot2 nodejs nodejs-loopback java-microprofile my-nodejs-express nodejs-express triggers Create a new file called collection.yaml in collections/incubator/my-nodejs-express , add the following: default-image : my-nodejs-express default-pipeline : default images : - id : my-nodejs-express image : $IMAGE_REGISTRY_ORG/my-nodejs-express:0.3 Edit the new file called stack.yaml in collections/incubator/my-nodejs-express . Update the name and description fields to add \"with Helmet\" and also replace the maintainer information with your information if desired (you will probably see a different version, don't change that and keep as-is): name : Node.js Express with Helmet version : 0.3.0 description : Express web framework for Node.js with Helmet license : Apache-2.0 language : nodejs maintainers : - name : Your Name email : your email github-id : yourgithubid default-template : simple And also create a directory called pipelines in collections/incubator/my-nodejs-express , and add a single empty file called .gitkeep .","title":"4. Add our custom stack to the new collection"},{"location":"exercise-6/#5-build-the-new-collection","text":"This step builds the kabanero-index.yaml file. From the collections directory, run the build script. For example: cd ~/appsody-apps/collections IMAGE_REGISTRY_ORG = $IMAGE_REGISTRY / $IMAGE_REGISTRY_ORG ./ci/build.sh NOTE : This process can take several minutes to complete. Note that this will build all the collections in the incubator directory, including the new my-nodejs-express stack. Following the build, you can find the generated collection assets in the collections/ci/assets/ directory and all the docker images in your local docker registry. You should see output like the following, take note of the my-nodejs-express stack being built, and ensure there are no errors in the output: ... Listing all stacks Building stacks: incubator/java-microprofile incubator/java-spring-boot2 incubator/my-nodejs-express incubator/nodejs-express incubator/nodejs-loopback incubator/nodejs ... - BUILDING stack: incubator/my-nodejs-express File containing output from image build: /Users/stevemar/appsody-apps/collections/ci/build/image.my-nodejs-express.0.2.8.log created kabanero/my-nodejs-express:0.2.8 --- Created template archive: incubator.my-nodejs-express.v0.2.8.templates.scaffold.tar.gz --- Created template archive: incubator.my-nodejs-express.v0.2.8.templates.simple.tar.gz ... === Testing my-nodejs-express : scaffold ~/appsody-apps/collections/ci/build/test/kabanero-index-local/my-nodejs-express/scaffold ~/appsody-apps/collections > appsody init kabanero-index-local/my-nodejs-express scaffold > appsody run -P --name my-nodejs-express-scaffold ... > appsody stop --name my-nodejs-express-scaffold Stopping development environment Running command: docker stop my-nodejs-express-scaffold ... > appsody build error = 0 ~/appsody-apps/collections","title":"5. Build the new collection"},{"location":"exercise-6/#6-push-collection-images","text":"To push the collection images, there is a release script that will do the actual pushing to the image registry. The current scripts have a minor issue with private registry login and tagging so first log in to the private registry, and then run the release script. The two commands below will achieve this: echo $IMAGE_REGISTRY_PASSWORD | docker login -u $IMAGE_REGISTRY_USERNAME --password-stdin $IMAGE_REGISTRY IMAGE_REGISTRY = \"\" IMAGE_REGISTRY_PASSWORD = \"\" ./ci/release.sh You should see output like the following, take note of the my-nodejs-express stack being pushed to the registry, and ensure there are no errors in the output: $ IMAGE_REGISTRY = \"\" IMAGE_REGISTRY_PASSWORD = \"\" ./ci/release.sh == Running pre_env.d scripts == Done pre_env.d scripts == Running post_env.d scripts == Done post_env.d scripts ... Releasing: /Users/stevemar/appsody-apps/collections/ci/assets/incubator.my-nodejs-express.v0.2.8.templates.scaffold.tar.gz Releasing: /Users/stevemar/appsody-apps/collections/ci/assets/incubator.my-nodejs-express.v0.2.8.templates.simple.tar.gz ... Pushing docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express The push refers to repository [ docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express ] 535ab22146d1: Layer already exists 0 : digest: sha256:535ab22146d1 size: 3883 535ab22146d1: Layer already exists 0 .2: digest: sha256:535ab22146d1 size: 3883 535ab22146d1: Layer already exists 0 .2.8: digest: sha256:535ab22146d1 size: 3883 535ab22146d1: Layer already exists latest: digest: sha256:535ab22146d1 size: 3883 Tagging docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2.8 > docker tag kabanero-noauth/my-nodejs-express:0.2.8 docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2.8 ... NOTE: Since this above is pushing a lot of images, it is possible that you might see this command fail with a timeout error, or unknown blob. Retrying the command (more than once if necessary) will resolve this issue.","title":"6. Push collection images"},{"location":"exercise-6/#7-update-code-repo-and-release-a-new-collection","text":"Once you have made all the changes to the collection and you are ready to push the changes back to your git repository then # Add your custom stack changes git add -A # Create a commit message git commit -m \"Updates to the collections\" # Push the changes to your repository. For example: git push -u my-org To create a full release of the collections, create a git tag: git tag 0 .2.1-custom -m \"Custom collections, version 0.2.1-custom\" git push --tags Navigating back to your GitHub repo, you should see a new release available: Clicking on the release name (0.2.1-custom) will allow you to edit the release. Click on Edit tag . and then upload all the files in collections/ci/release/ which were generated from the previous steps, by clicking on the Attach binaries... box. Once you have uploaded the files you can publish your new collection by clicking Publish release , at the bottom of the page You will note that the collection includes the kabanero-index.yaml file we edited earlier. The url to this index file is is what you will provide appsody as a link to your new custom repository (that is contained within the new collection. You normally obtain and copy the url (depending on your browser) by right (or secondary) clicking over the kabanero-index.yaml item in the list of files shown in the release. It should be of the form: https://github.com/<username>/collections/releases/download/0.2.1-custom/kabanero-index.yaml You will need this url for the next exercise, where we will create an appsody application based on your new collection. Congratulations!! We've just created our own custom collection that included our own custom stack. Now we need to test our released collection using Appsody. On to the next exercise.","title":"7. Update code repo and release a new collection"},{"location":"exercise-7/","text":"Exercise 7: Using a custom collection with Appsody \u00b6 In this exercise, we will show how to add the custom collection to your Appsody cli and to create an example application. Hint, this is going to be a lot like one of the exercises from day 1, but this time with your custom collection. When you have completed this exercise, you will understand how to update Appsody CLI to point to a new collection test out the custom stack in our custom collection Prerequisites \u00b6 You should have already carried out the prerequisites defined in Exercise 6 . Steps \u00b6 Get the collection URL Test the new stack and collection Prepare the new application for deployment 1. Get the collection URL \u00b6 Obtain the URL to the collection repository. If a Git release was created for the collections, generally, the URL format will be: https://<git repository>/<organization>/collections/releases/download/<release>/kabanero-index.yaml In our workshop, it'll likely be: https://github.com/<username>/collections/releases/download/0.2.1-custom/kabanero-index.yaml Replace <username> with your Github username 2. Test the new stack and collection \u00b6 Now that we know the URL, let's add the repo to our local appsody appsody repo add stevemar https://github.com/stevemar/collections/releases/download/0.2.1-custom/kabanero-index.yaml Create a new directory to work in: cd ~/appsody-apps mkdir test-custom-stack cd test-custom-stack Initialize the appsody stack appsody init stevemar/my-nodejs-express You should see output similar to the following: $ appsody init stevemar/my-nodejs-express Running appsody init... Downloading my-nodejs-express template project from https://github.com/stevemar/collections/releases/download/0.2.1-custom/incubator.my-nodejs-express.v0.2.8.templates.simple.tar.gz Download complete. Extracting files from /Users/stevemar/appsody-apps/testo/my-nodejs-express.tar.gz ... Pulling docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2 ... docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2 -c find /project -type f -name .appsody-init.sh Successfully initialized Appsody project Run the stack: appsody run You should see output similar to the following: $ appsody run Running development environment... ... Running docker command: docker run --rm -p 3000 :3000 -p 9229 :9229 --name testo-dev -v /Users/stevemar/appsody-apps/testo/:/project/user-app -v testo-deps:/project/user-app/node_modules -v /Users/stevemar/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2 --mode = run [ Container ] Running APPSODY_PREP command: npm install --prefix user-app && npm audit fix --prefix user-app added 170 packages from 578 contributors and audited 295 packages in 2 .989s [ Container ] found 0 vulnerabilities ... Application Metrics 5 .0.3.201908230949 ( Agent Core 4 .0.3 ) [ Container ] [ Tue Nov 12 03 :13:32 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 [ Container ] App started on PORT 3000 Test it out with curl and you'll see the helmet headers. Use the appsody stop command in another terminal in the same directory to stop the running application. 3. Prepare the new application for deployment \u00b6 Before you can deploy this application using the pipeline you will be building in the upcoming exercises, there needs to be a deployment file added to the application. The deployment file is called app-deploy.yaml . This file was created automatically for you in day 1 exercise 3 with the appsody deploy command. It can also be created without deploying an application using the --generate-only flag. Run this command: appsody deploy --generate-only $ appsody deploy --generate-only Extracting project from development environment Pulling docker image docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 Running command: docker pull docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 0 .3: Pulling from kabanero-noauth/my-nodejs-express Digest: sha256:9145b3477ca00e2401d100380460a5d813a6f291ee149d10ac7d989f1923f1e3 Status: Image is up to date for docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 Running command: docker run --name test-custom-stack-extract -v C:/Users/TimRobinson/appsody-apps/test-custom-stack/:/project/user-app --entrypoint /bin/bash docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 -c cp -rfL /project /tmp/project ... After the command completes, check the contents of the application directory with ls app.js app-deploy.yaml node_modules/ package.json package-lock.json test/ Congratulations!! We've got a published custom stack and it can be used for local development.","title":"Lab 7. Use a custom Collection with Appsody"},{"location":"exercise-7/#exercise-7-using-a-custom-collection-with-appsody","text":"In this exercise, we will show how to add the custom collection to your Appsody cli and to create an example application. Hint, this is going to be a lot like one of the exercises from day 1, but this time with your custom collection. When you have completed this exercise, you will understand how to update Appsody CLI to point to a new collection test out the custom stack in our custom collection","title":"Exercise 7: Using a custom collection with Appsody"},{"location":"exercise-7/#prerequisites","text":"You should have already carried out the prerequisites defined in Exercise 6 .","title":"Prerequisites"},{"location":"exercise-7/#steps","text":"Get the collection URL Test the new stack and collection Prepare the new application for deployment","title":"Steps"},{"location":"exercise-7/#1-get-the-collection-url","text":"Obtain the URL to the collection repository. If a Git release was created for the collections, generally, the URL format will be: https://<git repository>/<organization>/collections/releases/download/<release>/kabanero-index.yaml In our workshop, it'll likely be: https://github.com/<username>/collections/releases/download/0.2.1-custom/kabanero-index.yaml Replace <username> with your Github username","title":"1. Get the collection URL"},{"location":"exercise-7/#2-test-the-new-stack-and-collection","text":"Now that we know the URL, let's add the repo to our local appsody appsody repo add stevemar https://github.com/stevemar/collections/releases/download/0.2.1-custom/kabanero-index.yaml Create a new directory to work in: cd ~/appsody-apps mkdir test-custom-stack cd test-custom-stack Initialize the appsody stack appsody init stevemar/my-nodejs-express You should see output similar to the following: $ appsody init stevemar/my-nodejs-express Running appsody init... Downloading my-nodejs-express template project from https://github.com/stevemar/collections/releases/download/0.2.1-custom/incubator.my-nodejs-express.v0.2.8.templates.simple.tar.gz Download complete. Extracting files from /Users/stevemar/appsody-apps/testo/my-nodejs-express.tar.gz ... Pulling docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2 ... docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2 -c find /project -type f -name .appsody-init.sh Successfully initialized Appsody project Run the stack: appsody run You should see output similar to the following: $ appsody run Running development environment... ... Running docker command: docker run --rm -p 3000 :3000 -p 9229 :9229 --name testo-dev -v /Users/stevemar/appsody-apps/testo/:/project/user-app -v testo-deps:/project/user-app/node_modules -v /Users/stevemar/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.2 --mode = run [ Container ] Running APPSODY_PREP command: npm install --prefix user-app && npm audit fix --prefix user-app added 170 packages from 578 contributors and audited 295 packages in 2 .989s [ Container ] found 0 vulnerabilities ... Application Metrics 5 .0.3.201908230949 ( Agent Core 4 .0.3 ) [ Container ] [ Tue Nov 12 03 :13:32 2019 ] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883 [ Container ] App started on PORT 3000 Test it out with curl and you'll see the helmet headers. Use the appsody stop command in another terminal in the same directory to stop the running application.","title":"2. Test the new stack and collection"},{"location":"exercise-7/#3-prepare-the-new-application-for-deployment","text":"Before you can deploy this application using the pipeline you will be building in the upcoming exercises, there needs to be a deployment file added to the application. The deployment file is called app-deploy.yaml . This file was created automatically for you in day 1 exercise 3 with the appsody deploy command. It can also be created without deploying an application using the --generate-only flag. Run this command: appsody deploy --generate-only $ appsody deploy --generate-only Extracting project from development environment Pulling docker image docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 Running command: docker pull docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 0 .3: Pulling from kabanero-noauth/my-nodejs-express Digest: sha256:9145b3477ca00e2401d100380460a5d813a6f291ee149d10ac7d989f1923f1e3 Status: Image is up to date for docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 Running command: docker run --name test-custom-stack-extract -v C:/Users/TimRobinson/appsody-apps/test-custom-stack/:/project/user-app --entrypoint /bin/bash docker-registry-default.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/kabanero-noauth/my-nodejs-express:0.3 -c cp -rfL /project /tmp/project ... After the command completes, check the contents of the application directory with ls app.js app-deploy.yaml node_modules/ package.json package-lock.json test/ Congratulations!! We've got a published custom stack and it can be used for local development.","title":"3. Prepare the new application for deployment"},{"location":"exercise-8/","text":"Exercise 8: Create a custom Tekton Task and Pipleline \u00b6 In this exercise, we will show how to create Tekton artifacts, and how to plug into the existing pipelines and environment knowledge that Kabanero provides to those artifacts. When you have completed this exercise, you will understand how to create a custom Task in Tekton create a custom Pipeline in Tekton Prerequisites \u00b6 You should have already carried out the prerequisites defined in Exercise 7 . In addition, recall how to do the following from Exercise 4 Access the Tekton Dashboard Get a GitHub Access Token Steps \u00b6 Upload custom stack test to GitHub Create a custom Tekton Task Create a custom Tekton Pipeline Add a webhook to Tekton to watch Github for changes Test it all out 1. Upload custom stack test to GitHub \u00b6 From completing the previous exercise you should now have a code base in the following folder cd ~/appsody-apps/test-custom-stack ls -la Should result in output that looks like the following: $ ls -la total 144 drwxr-xr-x 14 stevemar staff 448 19 Nov 14 :20 . drwxr-xr-x 9 stevemar staff 288 19 Nov 16 :26 .. -rw-r--r-- 1 stevemar staff 70 15 Nov 10 :02 .appsody-config.yaml -rw-r--r-- 1 stevemar staff 1316 15 Nov 10 :02 .gitignore -rw-r--r-- 1 stevemar staff 130 15 Nov 10 :12 app.js drwxr-xr-x 2 stevemar staff 64 15 Nov 10 :03 node_modules -rw-r--r-- 1 stevemar staff 51421 15 Nov 10 :02 package-lock.json -rw-r--r-- 1 stevemar staff 455 19 Nov 12 :52 package.json drwxr-xr-x 3 stevemar staff 96 15 Nov 10 :02 test We will now upload that code to Github. Go to https://github.com/new and create a new repository, test-custom-stack . Do not initiatize the repos with a license file or README. From your test-custom-stack directory, run the commands below, replacing <username> with your own. git init git add -A git commit -m \"first commit\" git remote add my-org https://github.com:<username>/test-custom-stack.git git push -u my-org master The repo should look like this: 2. Create a custom Tekton Task \u00b6 Create a new directory to iterate on new tasks cd ~/appsody-apps mkdir tekton-tasks cd tekton-tasks Create a new file named test-task.yaml with the following contents: apiVersion : tekton.dev/v1alpha1 kind : Task metadata : name : test-task spec : inputs : resources : - name : git-source type : git steps : - name : test-echo image : kabanero/nodejs-express:0.2 workingDir : ${inputs.resources.git-source.path} command : - /bin/bash args : - -c - | set -e echo \"APPSODY_INSTALL:\" echo $APPSODY_INSTALL echo \"APPSODY_TEST:\" echo $APPSODY_TEST echo \"APPSODY_WATCH_DIR:\" echo $APPSODY_WATCH_DIR echo \"------\" echo \"My working directory is:\" pwd ls echo \"------\" echo \"I built my first Kabanero based Tekton task\" Run the following to create the Task in Tekton: oc apply -f test-task.yaml -n kabanero 3. Create a custom Tekton Pipeline \u00b6 Create a new file named test-pipeline.yaml with the following contents: apiVersion : tekton.dev/v1alpha1 kind : Pipeline metadata : name : test-pipeline spec : resources : - name : git-source type : git - name : docker-image type : image tasks : - name : test-task taskRef : name : test-task resources : inputs : - name : git-source resource : git-source Run the following to create the Pipeline in Tekton: oc apply -f test-pipeline.yaml -n kabanero 4. Add a webhook to Tekton to watch Github for changes \u00b6 From the Tekton dashboard, we need to add a new webhook. Launch a browser and access the dashboard. To configure the GitHub webhook to your repo. Go to Webhooks > Add Webhook and then create the webhook. Create a webhook for the backend \u00b6 Name: custom-stack-webhook Repository URL: http://github.com/{username}/test-custom-stack Access Token: github-tekton Namespace: kabanero Pipeline: test-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/kabanero Return to your git repo and check the Settings > Webhooks panel to verify that the webhook has been added and is working. 5. Test it all out \u00b6 In your test-custom-stack repo, change the file app.js . Change a value in the res.send(\"Hello from Appsody!\"); function. Then commit this change and push to your github repo, for example: git add -u git commit -m \"test change\" git push -f -u origin master This will trigger the tekton pipleine. Go to the tekton dashboard and access the new pipeline it created.","title":"Lab 8. Create a custom Tekton Task and Pipleline"},{"location":"exercise-8/#exercise-8-create-a-custom-tekton-task-and-pipleline","text":"In this exercise, we will show how to create Tekton artifacts, and how to plug into the existing pipelines and environment knowledge that Kabanero provides to those artifacts. When you have completed this exercise, you will understand how to create a custom Task in Tekton create a custom Pipeline in Tekton","title":"Exercise 8: Create a custom Tekton Task and Pipleline"},{"location":"exercise-8/#prerequisites","text":"You should have already carried out the prerequisites defined in Exercise 7 . In addition, recall how to do the following from Exercise 4 Access the Tekton Dashboard Get a GitHub Access Token","title":"Prerequisites"},{"location":"exercise-8/#steps","text":"Upload custom stack test to GitHub Create a custom Tekton Task Create a custom Tekton Pipeline Add a webhook to Tekton to watch Github for changes Test it all out","title":"Steps"},{"location":"exercise-8/#1-upload-custom-stack-test-to-github","text":"From completing the previous exercise you should now have a code base in the following folder cd ~/appsody-apps/test-custom-stack ls -la Should result in output that looks like the following: $ ls -la total 144 drwxr-xr-x 14 stevemar staff 448 19 Nov 14 :20 . drwxr-xr-x 9 stevemar staff 288 19 Nov 16 :26 .. -rw-r--r-- 1 stevemar staff 70 15 Nov 10 :02 .appsody-config.yaml -rw-r--r-- 1 stevemar staff 1316 15 Nov 10 :02 .gitignore -rw-r--r-- 1 stevemar staff 130 15 Nov 10 :12 app.js drwxr-xr-x 2 stevemar staff 64 15 Nov 10 :03 node_modules -rw-r--r-- 1 stevemar staff 51421 15 Nov 10 :02 package-lock.json -rw-r--r-- 1 stevemar staff 455 19 Nov 12 :52 package.json drwxr-xr-x 3 stevemar staff 96 15 Nov 10 :02 test We will now upload that code to Github. Go to https://github.com/new and create a new repository, test-custom-stack . Do not initiatize the repos with a license file or README. From your test-custom-stack directory, run the commands below, replacing <username> with your own. git init git add -A git commit -m \"first commit\" git remote add my-org https://github.com:<username>/test-custom-stack.git git push -u my-org master The repo should look like this:","title":"1. Upload custom stack test to GitHub"},{"location":"exercise-8/#2-create-a-custom-tekton-task","text":"Create a new directory to iterate on new tasks cd ~/appsody-apps mkdir tekton-tasks cd tekton-tasks Create a new file named test-task.yaml with the following contents: apiVersion : tekton.dev/v1alpha1 kind : Task metadata : name : test-task spec : inputs : resources : - name : git-source type : git steps : - name : test-echo image : kabanero/nodejs-express:0.2 workingDir : ${inputs.resources.git-source.path} command : - /bin/bash args : - -c - | set -e echo \"APPSODY_INSTALL:\" echo $APPSODY_INSTALL echo \"APPSODY_TEST:\" echo $APPSODY_TEST echo \"APPSODY_WATCH_DIR:\" echo $APPSODY_WATCH_DIR echo \"------\" echo \"My working directory is:\" pwd ls echo \"------\" echo \"I built my first Kabanero based Tekton task\" Run the following to create the Task in Tekton: oc apply -f test-task.yaml -n kabanero","title":"2. Create a custom Tekton Task"},{"location":"exercise-8/#3-create-a-custom-tekton-pipeline","text":"Create a new file named test-pipeline.yaml with the following contents: apiVersion : tekton.dev/v1alpha1 kind : Pipeline metadata : name : test-pipeline spec : resources : - name : git-source type : git - name : docker-image type : image tasks : - name : test-task taskRef : name : test-task resources : inputs : - name : git-source resource : git-source Run the following to create the Pipeline in Tekton: oc apply -f test-pipeline.yaml -n kabanero","title":"3. Create a custom Tekton Pipeline"},{"location":"exercise-8/#4-add-a-webhook-to-tekton-to-watch-github-for-changes","text":"From the Tekton dashboard, we need to add a new webhook. Launch a browser and access the dashboard. To configure the GitHub webhook to your repo. Go to Webhooks > Add Webhook and then create the webhook.","title":"4. Add a webhook to Tekton to watch Github for changes"},{"location":"exercise-8/#create-a-webhook-for-the-backend","text":"Name: custom-stack-webhook Repository URL: http://github.com/{username}/test-custom-stack Access Token: github-tekton Namespace: kabanero Pipeline: test-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/kabanero Return to your git repo and check the Settings > Webhooks panel to verify that the webhook has been added and is working.","title":"Create a webhook for the backend"},{"location":"exercise-8/#5-test-it-all-out","text":"In your test-custom-stack repo, change the file app.js . Change a value in the res.send(\"Hello from Appsody!\"); function. Then commit this change and push to your github repo, for example: git add -u git commit -m \"test change\" git push -f -u origin master This will trigger the tekton pipleine. Go to the tekton dashboard and access the new pipeline it created.","title":"5. Test it all out"},{"location":"exercise-9/","text":"Exercise 9: Deploy an application with a custom Stack, custom Collection, and custom Pipeline \u00b6 In this exercise, we will show how to bring all the custom components (Stacks, Collections, Pipelines) together. When you have completed this exercise, you will understand how to Create a custom pipeline and add it to a collection Update the Kabanero Custom Resource to point to a new collection Deploy an application based on a custom stack using a custom Tekton pipeline Prerequisites \u00b6 You should have already carried out the prerequisites defined in Exercise 8 . Delete the webhook from Exercise 8: Open the Tekton dashboard, and select Webhooks . Next, click on the box next to the custom-slack-webhook to select it and click on Delete . In the dialog, check the box to delete pipeline runs associated with the webhook and click on Confirm . Delete the task and pipeline from Exercise 8, too. cd ~/appsody-apps/tekton-tasks oc delete -f test-pipeline.yaml oc delete -f test-task.yaml Steps \u00b6 1. Add the tasks to the collection \u00b6 In your local collections/incubator/my-nodejs-express/pipelines folder add a new folder called custom-pipeline and add two files test-task.yaml and test-build-deploy-pipeline.yaml . The file structure is seen below incubator \u2514\u2500\u2500 my-nodejs-express/ \u2514\u2500\u2500 pipelines/ \u2514\u2500\u2500 custom-pipeline/ \u2514\u2500\u2500 test-task.yaml \u2514\u2500\u2500 test-build-deploy-pipeline.yaml The test-task.yaml is slightly updated from exercise 8 to pull in the relevant basename from any collection that uses it #Kabanero! on activate substitute CollectionId for text 'CollectionId' apiVersion : tekton.dev/v1alpha1 kind : Task metadata : name : CollectionId-test-task spec : inputs : resources : - name : git-source type : git outputs : resources : - name : docker-image type : image steps : - name : test-echo image : kabanero/nodejs-express:0.2 workingDir : ${inputs.resources.git-source.path} command : - /bin/bash args : - -c - | set -e echo \"APPSODY_INSTALL:\" echo $APPSODY_INSTALL echo \"APPSODY_TEST:\" echo $APPSODY_TEST echo \"APPSODY_WATCH_DIR:\" echo $APPSODY_WATCH_DIR echo \"------\" echo \"My working directory is:\" pwd ls echo \"------\" echo \"I built my first Kabanero based Tekton task\" And the test-build-deploy-pipeline.yaml is a modification of the defauly pipeline: #Kabanero! on activate substitute CollectionId for text 'CollectionId' apiVersion : tekton.dev/v1alpha1 kind : Pipeline metadata : name : CollectionId-test-build-deploy-pipeline spec : resources : - name : git-source type : git - name : docker-image type : image tasks : - name : test-task taskRef : name : CollectionId-test-task resources : inputs : - name : git-source resource : git-source outputs : - name : docker-image resource : docker-image - name : build-task taskRef : name : CollectionId-build-task runAfter : [ test-task ] resources : inputs : - name : git-source resource : git-source outputs : - name : docker-image resource : docker-image - name : deploy-task taskRef : name : CollectionId-deploy-task runAfter : [ build-task ] resources : inputs : - name : git-source resource : git-source - name : docker-image resource : docker-image In incubator/my-nodejs-express update collection.yaml to change the default pipeline default-image : my-nodejs-express default-pipeline : my-nodejs-express-test-build-deploy-pipeline images : - id : my-nodejs-express image : $IMAGE_REGISTRY_ORG/my-nodejs-express:0.3 Unusually in these exercises, we have been using a version of appsody that is ahead of the current level baked into some the standard kabanero tekton artifacts, so there is one additional change that is needed to get around this. You need to update a tag in the common build-task.yaml used for all stacks in the collection. This update will select a builder container that uses appsody 0.5.3 to support the private registry semantics used in these exercises. Open the incubator/common/pipelines/default/build-task.yaml file and add the tag :0.5.3-buildah1.9.0 to the image spec in the assemble-extract step as shown: #Kabanero! on activate substitute CollectionId for text 'CollectionId' apiVersion : tekton.dev/v1alpha1 kind : Task metadata : name : CollectionId-build-task spec : inputs : resources : - name : git-source type : git params : - name : pathToDockerFile default : /workspace/extracted/Dockerfile - name : pathToContext default : /workspace/extracted outputs : resources : - name : docker-image type : image steps : - name : assemble-extract securityContext : privileged : true image : appsody/appsody-buildah:0.5.3-buildah1.9.0 command : [ \"/bin/bash\" ] args : - -c - \"/extract.sh\" env : - name : gitsource value : git-source volumeMounts : - mountPath : /var/lib/containers name : varlibcontainers ... 2. Re-run the scripts \u00b6 Run build.sh and release.sh as before. From collections home run: IMAGE_REGISTRY_ORG = $IMAGE_REGISTRY / $IMAGE_REGISTRY_ORG ./ci/build.sh IMAGE_REGISTRY = \"\" IMAGE_REGISTRY_PASSWORD = \"\" ./ci/release.sh Check the ci/release/ folder to make sure there is a file called (your version may be different): incubator.my-nodejs-express.v0.3.0.pipeline.custom-pipeline.tar.gz And that the generated ci/release/kabanero-index.yaml has a section like the following: - default-image : my-nodejs-express ... pipelines : - id : custom-pipeline sha256 : e3c3050850bf88b97c8fba728592d0cf671bb9d27b582ebaa9f90d939bfa60a5 url : https://github.com/stevemar/collections/releases/download/0.2.1-custom/incubator.my-nodejs-express.v0.3.0.pipeline.custom-pipeline.tar.gz 3. Update the current release \u00b6 Upload the changes # Add your custom stack changes git add -A # Create a commit message git commit -m \"Add custom task and pipeline\" # Push the changes to your repository. For example: git push -u my-org Navigating back to your GitHub repo, select the current custom release: Clicking on the release name (0.2.1-custom) will allow you to edit the release. Click on Edit tag . Click on the x to delete existing items from the release and then upload all the files in collections/ci/release/ which were generated from the previous steps, by clicking on the Attach binaries... box. 4. Update the Kabanero Custom Resource \u00b6 Use oc get kabaneros -n kabanero to obtain a list of all Kabanero CR instances in namespace kabanero . The default name for the CR instance is kabanero . oc get kabaneros -n kabanero You should see output similar to the following: $ oc get kabaneros -n kabanero NAME AGE VERSION READY kabanero 17d 0 .1.0 True Edit the specific CR instance using oc edit kabaneros <name> -n kabanero , replacing <name> with the instance name. oc edit kabaneros kabanero -n kabanero Modify your Kabanero custom resource (CR) instance to target the new collections that were pushed to the remote Github repository. The Spec.Collections.Repositories.url attribute should be set to the URL of the collection repository. apiVersion : kabanero.io/v1alpha1 kind : Kabanero metadata : name : kabanero namespace : kabanero spec : collections : repositories : - name : custom url : https://github.com/<username>/collections/releases/download/0.2.1-custom/kabanero-index.yaml activateDefaultCollections : true When you are done editing, save your changes and exit the editor. The updated Kabanero CR instance will be applied to your cluster. 5. Test it all out \u00b6 If you go to the tekton dashboard, you should see the new pipeline and task (it was added when updating the Kabanero CR by the Kabanero Operator) Re-add the webhook, this time you should see the new pipeline as an option (without having to do kubectl apply ). Use similar settings for the webhook as in Exercise 8: Name: custom-stack-webhook Repository URL: http://github.com/{username}/test-custom-stack Access Token: github-tekton Namespace: kabanero Pipeline: my-nodejs-express-test-build-deploy-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/kabanero When the pipeline runs, it should, in addition to running the new test task, also run the build and deploy task. You can test this by making a minor update to your test-custom-stack repo. Once you have done this then re-commit to trigger the webhook by: git add -u git commit -m \"Minor update to test pipeline\" git push -u my-org Return to the Tekton Pipeline Runs tab to check on the status of your deployment. After a while it should show that the pipeline run is complete. You can also click on the specific pipeline run link ( custom-stack-1576283066 in the above example), and see the progress of the three tasks which make up the new pipeline. Once they are all complete, it should look similar to the picture below. Notice how you can click on a given task (e.g. the new test-task we created) to see the output. Although the task we added was a test task, you can imagine how you might add additional tasks that are more relevant to your enterprise environment - for example to check that the application code added by the developer meets your security standards. Once the pipeline run is complete, you can confirm that our test application, with the upgraded stack, is now running with a curl -v to the route. You should see helmet responses, e.g.: $ curl -v http://test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdom ain.cloud/ * Trying 169 .62.48.20... * TCP_NODELAY set * Connected to test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud ( 169 .62.48.20 ) port 80 ( #0) > GET / HTTP/1.1 > Host: test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud > User-Agent: curl/7.63.0 > Accept: */* > < HTTP/1.1 200 OK < X-DNS-Prefetch-Control: off < X-Frame-Options: SAMEORIGIN < Strict-Transport-Security: max-age = 15552000 ; includeSubDomains < X-Download-Options: noopen < X-Content-Type-Options: nosniff < X-XSS-Protection: 1 ; mode = block < X-Powered-By: Express < Content-Type: text/html ; charset = utf-8 < Content-Length: 34 < ETag: W/ \"22-E8hT/HhjJRx/5AG3TOq9TBd5R7g\" < Date: Sat, 14 Dec 2019 00 :40:30 GMT < Set-Cookie: e23eec15db4cc24793d795555bb55650 = b8749458e2714fe3be1767f782a35058 ; path = / ; HttpOnly < Cache-control: private < Hello from a Custom Appsody Stack!* Connection #0 to host test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud left intact Congratulations!! You have completed Day 2 of the workshop! You have successfully created a custom appsody stack, included it in a custom Collection that also includes a custom pipeline - showing how you can adapt the standard kabanero infrastructure to suit the needs of your enterprise.","title":"Lab 9. Deploy a customized Kabanero application"},{"location":"exercise-9/#exercise-9-deploy-an-application-with-a-custom-stack-custom-collection-and-custom-pipeline","text":"In this exercise, we will show how to bring all the custom components (Stacks, Collections, Pipelines) together. When you have completed this exercise, you will understand how to Create a custom pipeline and add it to a collection Update the Kabanero Custom Resource to point to a new collection Deploy an application based on a custom stack using a custom Tekton pipeline","title":"Exercise 9: Deploy an application with a custom Stack, custom Collection, and custom Pipeline"},{"location":"exercise-9/#prerequisites","text":"You should have already carried out the prerequisites defined in Exercise 8 . Delete the webhook from Exercise 8: Open the Tekton dashboard, and select Webhooks . Next, click on the box next to the custom-slack-webhook to select it and click on Delete . In the dialog, check the box to delete pipeline runs associated with the webhook and click on Confirm . Delete the task and pipeline from Exercise 8, too. cd ~/appsody-apps/tekton-tasks oc delete -f test-pipeline.yaml oc delete -f test-task.yaml","title":"Prerequisites"},{"location":"exercise-9/#steps","text":"","title":"Steps"},{"location":"exercise-9/#1-add-the-tasks-to-the-collection","text":"In your local collections/incubator/my-nodejs-express/pipelines folder add a new folder called custom-pipeline and add two files test-task.yaml and test-build-deploy-pipeline.yaml . The file structure is seen below incubator \u2514\u2500\u2500 my-nodejs-express/ \u2514\u2500\u2500 pipelines/ \u2514\u2500\u2500 custom-pipeline/ \u2514\u2500\u2500 test-task.yaml \u2514\u2500\u2500 test-build-deploy-pipeline.yaml The test-task.yaml is slightly updated from exercise 8 to pull in the relevant basename from any collection that uses it #Kabanero! on activate substitute CollectionId for text 'CollectionId' apiVersion : tekton.dev/v1alpha1 kind : Task metadata : name : CollectionId-test-task spec : inputs : resources : - name : git-source type : git outputs : resources : - name : docker-image type : image steps : - name : test-echo image : kabanero/nodejs-express:0.2 workingDir : ${inputs.resources.git-source.path} command : - /bin/bash args : - -c - | set -e echo \"APPSODY_INSTALL:\" echo $APPSODY_INSTALL echo \"APPSODY_TEST:\" echo $APPSODY_TEST echo \"APPSODY_WATCH_DIR:\" echo $APPSODY_WATCH_DIR echo \"------\" echo \"My working directory is:\" pwd ls echo \"------\" echo \"I built my first Kabanero based Tekton task\" And the test-build-deploy-pipeline.yaml is a modification of the defauly pipeline: #Kabanero! on activate substitute CollectionId for text 'CollectionId' apiVersion : tekton.dev/v1alpha1 kind : Pipeline metadata : name : CollectionId-test-build-deploy-pipeline spec : resources : - name : git-source type : git - name : docker-image type : image tasks : - name : test-task taskRef : name : CollectionId-test-task resources : inputs : - name : git-source resource : git-source outputs : - name : docker-image resource : docker-image - name : build-task taskRef : name : CollectionId-build-task runAfter : [ test-task ] resources : inputs : - name : git-source resource : git-source outputs : - name : docker-image resource : docker-image - name : deploy-task taskRef : name : CollectionId-deploy-task runAfter : [ build-task ] resources : inputs : - name : git-source resource : git-source - name : docker-image resource : docker-image In incubator/my-nodejs-express update collection.yaml to change the default pipeline default-image : my-nodejs-express default-pipeline : my-nodejs-express-test-build-deploy-pipeline images : - id : my-nodejs-express image : $IMAGE_REGISTRY_ORG/my-nodejs-express:0.3 Unusually in these exercises, we have been using a version of appsody that is ahead of the current level baked into some the standard kabanero tekton artifacts, so there is one additional change that is needed to get around this. You need to update a tag in the common build-task.yaml used for all stacks in the collection. This update will select a builder container that uses appsody 0.5.3 to support the private registry semantics used in these exercises. Open the incubator/common/pipelines/default/build-task.yaml file and add the tag :0.5.3-buildah1.9.0 to the image spec in the assemble-extract step as shown: #Kabanero! on activate substitute CollectionId for text 'CollectionId' apiVersion : tekton.dev/v1alpha1 kind : Task metadata : name : CollectionId-build-task spec : inputs : resources : - name : git-source type : git params : - name : pathToDockerFile default : /workspace/extracted/Dockerfile - name : pathToContext default : /workspace/extracted outputs : resources : - name : docker-image type : image steps : - name : assemble-extract securityContext : privileged : true image : appsody/appsody-buildah:0.5.3-buildah1.9.0 command : [ \"/bin/bash\" ] args : - -c - \"/extract.sh\" env : - name : gitsource value : git-source volumeMounts : - mountPath : /var/lib/containers name : varlibcontainers ...","title":"1. Add the tasks to the collection"},{"location":"exercise-9/#2-re-run-the-scripts","text":"Run build.sh and release.sh as before. From collections home run: IMAGE_REGISTRY_ORG = $IMAGE_REGISTRY / $IMAGE_REGISTRY_ORG ./ci/build.sh IMAGE_REGISTRY = \"\" IMAGE_REGISTRY_PASSWORD = \"\" ./ci/release.sh Check the ci/release/ folder to make sure there is a file called (your version may be different): incubator.my-nodejs-express.v0.3.0.pipeline.custom-pipeline.tar.gz And that the generated ci/release/kabanero-index.yaml has a section like the following: - default-image : my-nodejs-express ... pipelines : - id : custom-pipeline sha256 : e3c3050850bf88b97c8fba728592d0cf671bb9d27b582ebaa9f90d939bfa60a5 url : https://github.com/stevemar/collections/releases/download/0.2.1-custom/incubator.my-nodejs-express.v0.3.0.pipeline.custom-pipeline.tar.gz","title":"2. Re-run the scripts"},{"location":"exercise-9/#3-update-the-current-release","text":"Upload the changes # Add your custom stack changes git add -A # Create a commit message git commit -m \"Add custom task and pipeline\" # Push the changes to your repository. For example: git push -u my-org Navigating back to your GitHub repo, select the current custom release: Clicking on the release name (0.2.1-custom) will allow you to edit the release. Click on Edit tag . Click on the x to delete existing items from the release and then upload all the files in collections/ci/release/ which were generated from the previous steps, by clicking on the Attach binaries... box.","title":"3. Update the current release"},{"location":"exercise-9/#4-update-the-kabanero-custom-resource","text":"Use oc get kabaneros -n kabanero to obtain a list of all Kabanero CR instances in namespace kabanero . The default name for the CR instance is kabanero . oc get kabaneros -n kabanero You should see output similar to the following: $ oc get kabaneros -n kabanero NAME AGE VERSION READY kabanero 17d 0 .1.0 True Edit the specific CR instance using oc edit kabaneros <name> -n kabanero , replacing <name> with the instance name. oc edit kabaneros kabanero -n kabanero Modify your Kabanero custom resource (CR) instance to target the new collections that were pushed to the remote Github repository. The Spec.Collections.Repositories.url attribute should be set to the URL of the collection repository. apiVersion : kabanero.io/v1alpha1 kind : Kabanero metadata : name : kabanero namespace : kabanero spec : collections : repositories : - name : custom url : https://github.com/<username>/collections/releases/download/0.2.1-custom/kabanero-index.yaml activateDefaultCollections : true When you are done editing, save your changes and exit the editor. The updated Kabanero CR instance will be applied to your cluster.","title":"4. Update the Kabanero Custom Resource"},{"location":"exercise-9/#5-test-it-all-out","text":"If you go to the tekton dashboard, you should see the new pipeline and task (it was added when updating the Kabanero CR by the Kabanero Operator) Re-add the webhook, this time you should see the new pipeline as an option (without having to do kubectl apply ). Use similar settings for the webhook as in Exercise 8: Name: custom-stack-webhook Repository URL: http://github.com/{username}/test-custom-stack Access Token: github-tekton Namespace: kabanero Pipeline: my-nodejs-express-test-build-deploy-pipeline Service account: kabanero-operator Docker Registry: docker-registry.default.svc:5000/kabanero When the pipeline runs, it should, in addition to running the new test task, also run the build and deploy task. You can test this by making a minor update to your test-custom-stack repo. Once you have done this then re-commit to trigger the webhook by: git add -u git commit -m \"Minor update to test pipeline\" git push -u my-org Return to the Tekton Pipeline Runs tab to check on the status of your deployment. After a while it should show that the pipeline run is complete. You can also click on the specific pipeline run link ( custom-stack-1576283066 in the above example), and see the progress of the three tasks which make up the new pipeline. Once they are all complete, it should look similar to the picture below. Notice how you can click on a given task (e.g. the new test-task we created) to see the output. Although the task we added was a test task, you can imagine how you might add additional tasks that are more relevant to your enterprise environment - for example to check that the application code added by the developer meets your security standards. Once the pipeline run is complete, you can confirm that our test application, with the upgraded stack, is now running with a curl -v to the route. You should see helmet responses, e.g.: $ curl -v http://test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdom ain.cloud/ * Trying 169 .62.48.20... * TCP_NODELAY set * Connected to test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud ( 169 .62.48.20 ) port 80 ( #0) > GET / HTTP/1.1 > Host: test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud > User-Agent: curl/7.63.0 > Accept: */* > < HTTP/1.1 200 OK < X-DNS-Prefetch-Control: off < X-Frame-Options: SAMEORIGIN < Strict-Transport-Security: max-age = 15552000 ; includeSubDomains < X-Download-Options: noopen < X-Content-Type-Options: nosniff < X-XSS-Protection: 1 ; mode = block < X-Powered-By: Express < Content-Type: text/html ; charset = utf-8 < Content-Length: 34 < ETag: W/ \"22-E8hT/HhjJRx/5AG3TOq9TBd5R7g\" < Date: Sat, 14 Dec 2019 00 :40:30 GMT < Set-Cookie: e23eec15db4cc24793d795555bb55650 = b8749458e2714fe3be1767f782a35058 ; path = / ; HttpOnly < Cache-control: private < Hello from a Custom Appsody Stack!* Connection #0 to host test-custom-stack-kabanero.timro-roks1-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud left intact Congratulations!! You have completed Day 2 of the workshop! You have successfully created a custom appsody stack, included it in a custom Collection that also includes a custom pipeline - showing how you can adapt the standard kabanero infrastructure to suit the needs of your enterprise.","title":"5. Test it all out"},{"location":"instructor-guide/","text":"Instructor guide \u00b6 The content in this section is specifically made for instructors hosting this workshop. Logging into Tekton UI \u00b6 To log into the Tekton UI, you need to authenticate with the OpenShift cluster is was deployed on. This means that if we spin up 1 or N clusters for every workshop participant, then they all need to be added to the a single IBM Cloud account beforehand, and consequently must have an IBM ID, too. Pushing to the OpenShift registry times out \u00b6 It's possible that when deploying a large image to OpenShift's internal registry, the deployment times out, with an error message like this: $ appsody deploy --tag $DOCKER_REGISTRY /insurance-quote/quote-backend:v1 --push --namespace insurance-quote ... [ Docker ] Successfully built 89b220cafd4a [ Docker ] Successfully tagged docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 Built docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 Using applicationImage of: docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 Pushing docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 [ Error ] Could not push the image: exit status 1 The push refers to repository [ docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend ] 9176e849956e: Preparing 25311323356d: Preparing c7a362505ffd: Layer already exists 4487d7944a84: Layer already exists 9176e849956e: Pushed 34c263b82e37: Retrying in 5 seconds To get around this issue, the IOPS (input/output operations per second) should be upgraded past the default (0.25). To do this, follow this guide (or see the Official Documentation ). First, find the OpenShift volume claim ID for registry-backing . To do this run: oc get pvc --all-namespaces You should see output similar to the snippet below, in this case the volume claim ID is pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 . $ oc get pvc --all-namespaces NAMESPACE NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE default registry-backing Bound pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 20Gi RWX ibmc-file-bronze 4d Use oc describe pv to find the volume ID (this is different than the volume claim ID), and can be found in the Labels section of the output. In this case it is 102411628 . $ oc describe pv pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 --namespace default Name: pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 Labels: CapacityGb = 20 Datacenter = wdc04 Iops = 2 StorageType = ENDURANCE Username = IBM02SEV1323471_4322 billingType = hourly failure-domain.beta.kubernetes.io/region = us-east failure-domain.beta.kubernetes.io/zone = wdc04 path = IBM02SEV1323471_4322data01 server = fsf-wdc0401h-fz.service.softlayer.com volumeId = 102411628 Annotations: ibmFileProvisionerIdentity = 8d6ff3ed-f695-11e9-9ecf-66243bd50687 pv.kubernetes.io/provisioned-by = ibm.io/ibmc-file Finalizers: [ kubernetes.io/pv-protection ] StorageClass: ibmc-file-bronze Status: Bound Claim: default/registry-backing Reclaim Policy: Delete Access Modes: RWX Capacity: 20Gi Node Affinity: <none> Message: Source: Type: NFS ( an NFS mount that lasts the lifetime of a pod ) Server: fsf-wdc0401h-fz.service.softlayer.com Path: /IBM02SEV1323471_4322/data01 ReadOnly: false Events: <none> Lastly, use the ibmcloud sl file command to modify the volume to have 10 IOPS. This may take several minutes to complete. $ ibmcloud sl file volume-modify 102411628 --new-tier 10 This action will incur charges on your account. Continue?> y Alternatively, should the CLI fail, modifying the volume can be done be accomplished from the IBM Cloud Dashboard. Navigate to https://cloud.ibm.com/classic/storage/file/{id} , where {id} is the volume ID. Choose to modify the volume, and choose an IOPS of 10.","title":"Instructor Guide"},{"location":"instructor-guide/#instructor-guide","text":"The content in this section is specifically made for instructors hosting this workshop.","title":"Instructor guide"},{"location":"instructor-guide/#logging-into-tekton-ui","text":"To log into the Tekton UI, you need to authenticate with the OpenShift cluster is was deployed on. This means that if we spin up 1 or N clusters for every workshop participant, then they all need to be added to the a single IBM Cloud account beforehand, and consequently must have an IBM ID, too.","title":"Logging into Tekton UI"},{"location":"instructor-guide/#pushing-to-the-openshift-registry-times-out","text":"It's possible that when deploying a large image to OpenShift's internal registry, the deployment times out, with an error message like this: $ appsody deploy --tag $DOCKER_REGISTRY /insurance-quote/quote-backend:v1 --push --namespace insurance-quote ... [ Docker ] Successfully built 89b220cafd4a [ Docker ] Successfully tagged docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 Built docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 Using applicationImage of: docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 Pushing docker image docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend:1 [ Error ] Could not push the image: exit status 1 The push refers to repository [ docker-registry-default.cp4apps-workshop-prop-5290c8c8e5797924dc1ad5d1b85b37c0-0001.us-east.containers.appdomain.cloud/insurance-quote/quote-backend ] 9176e849956e: Preparing 25311323356d: Preparing c7a362505ffd: Layer already exists 4487d7944a84: Layer already exists 9176e849956e: Pushed 34c263b82e37: Retrying in 5 seconds To get around this issue, the IOPS (input/output operations per second) should be upgraded past the default (0.25). To do this, follow this guide (or see the Official Documentation ). First, find the OpenShift volume claim ID for registry-backing . To do this run: oc get pvc --all-namespaces You should see output similar to the snippet below, in this case the volume claim ID is pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 . $ oc get pvc --all-namespaces NAMESPACE NAME STATUS VOLUME CAPACITY ACCESS MODES STORAGECLASS AGE default registry-backing Bound pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 20Gi RWX ibmc-file-bronze 4d Use oc describe pv to find the volume ID (this is different than the volume claim ID), and can be found in the Labels section of the output. In this case it is 102411628 . $ oc describe pv pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 --namespace default Name: pvc-82769bfa-f694-11e9-bf77-faf40b1b6da7 Labels: CapacityGb = 20 Datacenter = wdc04 Iops = 2 StorageType = ENDURANCE Username = IBM02SEV1323471_4322 billingType = hourly failure-domain.beta.kubernetes.io/region = us-east failure-domain.beta.kubernetes.io/zone = wdc04 path = IBM02SEV1323471_4322data01 server = fsf-wdc0401h-fz.service.softlayer.com volumeId = 102411628 Annotations: ibmFileProvisionerIdentity = 8d6ff3ed-f695-11e9-9ecf-66243bd50687 pv.kubernetes.io/provisioned-by = ibm.io/ibmc-file Finalizers: [ kubernetes.io/pv-protection ] StorageClass: ibmc-file-bronze Status: Bound Claim: default/registry-backing Reclaim Policy: Delete Access Modes: RWX Capacity: 20Gi Node Affinity: <none> Message: Source: Type: NFS ( an NFS mount that lasts the lifetime of a pod ) Server: fsf-wdc0401h-fz.service.softlayer.com Path: /IBM02SEV1323471_4322/data01 ReadOnly: false Events: <none> Lastly, use the ibmcloud sl file command to modify the volume to have 10 IOPS. This may take several minutes to complete. $ ibmcloud sl file volume-modify 102411628 --new-tier 10 This action will incur charges on your account. Continue?> y Alternatively, should the CLI fail, modifying the volume can be done be accomplished from the IBM Cloud Dashboard. Navigate to https://cloud.ibm.com/classic/storage/file/{id} , where {id} is the volume ID. Choose to modify the volume, and choose an IOPS of 10.","title":"Pushing to the OpenShift registry times out"},{"location":"pre-work/","text":"Pre-work \u00b6 This section is broken up into the following steps: Accounts Install Docker Install Appsody CLI Install OpenShift CLI Check access to OpenShift cluster Ensure Cloud Pak for Applications is installed Install VS Code (Optional) 1. Accounts \u00b6 The following accounts are needed for this workshop: Github IBM Cloud 2. Install Docker \u00b6 A key part of the Appsody development experience is Rapid Local Development Mode, where the code you develop is continuously being run in a local docker container. If you don't already have Docker installed on your machine, you should do so now: Install Docker for macOS Install Docker for Windows If you are not familiar with Docker Desktop, you can learn more about the orientation and setup here . docker version You should see output similar to the following: $ docker version Client: Docker Engine - Community Version: 19 .03.4 ... 3. Install Appsody CLI \u00b6 Appsody includes a CLI which allows you to manage you stack based development (this workshop requries version 0.5.0 or later). This should be installed on your development machine: Install the Appsody CLI You can check that you have the correct version installed by executing the command: appsody version You should see output similar to the following: $ appsody version appsody 0 .5.3 4. Install OpenShift CLI \u00b6 The OpenShift CLI allows you to manage OpenShift resources from a terminal (this workshop requries version 3.11 ( not 4.x )). This should be installed on your development machine: Install the OpenShift CLI You can check that you have the correct version installed by executing the command: oc version You should see output similar to the following: $ oc version oc v3.11.0+0cbc58b ... 5. Check access to OpenShift cluster \u00b6 You should already have been provided with details of a managed OpenShift cluster that has been provisioned for you. Check you have access to this by using the oc login with the credentials the workshop administrator provides to you. oc login <url> --token = <token> 6. Ensure Cloud Pak for Applications is installed \u00b6 Cloud Pak for Applications should already have been installed in your managed OpenShift cluster. Check you have access to this by ensuring that Cloud Pak for Applications exists in the Application Console of your OpenShift cluster. When clicked, the Cloud Pak for Applications landing page should appear: Clicking on the Instance menu link will show you information about Kabanero. 7. Install VS Code \u00b6 VS Code and its Codewind extension are used in a number of steps in Exercise 1 . Although it is possible to comlete the workshop without these steps, we recommend you install VSCode on your machine if you don't have it already, using the following link: Install VSCode","title":"Pre-work"},{"location":"pre-work/#pre-work","text":"This section is broken up into the following steps: Accounts Install Docker Install Appsody CLI Install OpenShift CLI Check access to OpenShift cluster Ensure Cloud Pak for Applications is installed Install VS Code (Optional)","title":"Pre-work"},{"location":"pre-work/#1-accounts","text":"The following accounts are needed for this workshop: Github IBM Cloud","title":"1. Accounts"},{"location":"pre-work/#2-install-docker","text":"A key part of the Appsody development experience is Rapid Local Development Mode, where the code you develop is continuously being run in a local docker container. If you don't already have Docker installed on your machine, you should do so now: Install Docker for macOS Install Docker for Windows If you are not familiar with Docker Desktop, you can learn more about the orientation and setup here . docker version You should see output similar to the following: $ docker version Client: Docker Engine - Community Version: 19 .03.4 ...","title":"2. Install Docker"},{"location":"pre-work/#3-install-appsody-cli","text":"Appsody includes a CLI which allows you to manage you stack based development (this workshop requries version 0.5.0 or later). This should be installed on your development machine: Install the Appsody CLI You can check that you have the correct version installed by executing the command: appsody version You should see output similar to the following: $ appsody version appsody 0 .5.3","title":"3. Install Appsody CLI"},{"location":"pre-work/#4-install-openshift-cli","text":"The OpenShift CLI allows you to manage OpenShift resources from a terminal (this workshop requries version 3.11 ( not 4.x )). This should be installed on your development machine: Install the OpenShift CLI You can check that you have the correct version installed by executing the command: oc version You should see output similar to the following: $ oc version oc v3.11.0+0cbc58b ...","title":"4. Install OpenShift CLI"},{"location":"pre-work/#5-check-access-to-openshift-cluster","text":"You should already have been provided with details of a managed OpenShift cluster that has been provisioned for you. Check you have access to this by using the oc login with the credentials the workshop administrator provides to you. oc login <url> --token = <token>","title":"5. Check access to OpenShift cluster"},{"location":"pre-work/#6-ensure-cloud-pak-for-applications-is-installed","text":"Cloud Pak for Applications should already have been installed in your managed OpenShift cluster. Check you have access to this by ensuring that Cloud Pak for Applications exists in the Application Console of your OpenShift cluster. When clicked, the Cloud Pak for Applications landing page should appear: Clicking on the Instance menu link will show you information about Kabanero.","title":"6. Ensure Cloud Pak for Applications is installed"},{"location":"pre-work/#7-install-vs-code","text":"VS Code and its Codewind extension are used in a number of steps in Exercise 1 . Although it is possible to comlete the workshop without these steps, we recommend you install VSCode on your machine if you don't have it already, using the following link: Install VSCode","title":"7. Install VS Code"},{"location":"resources/","text":"Additional resources \u00b6 Lectures \u00b6 Lecture 1: What is Cloud Native? Lecture 2: Kabanero Overview Lecture 3: Adding value with IBM Cloud Pak for Applications Lecture 4: Customizing Appsody and Kabanero Lecture 5: Tekton Overview Links \u00b6 IBM Developer Appsody Documentation Kabanero Documentation Codewind Documentation Cloud Pak for Applications","title":"Additional resources"},{"location":"resources/#additional-resources","text":"","title":"Additional resources"},{"location":"resources/#lectures","text":"Lecture 1: What is Cloud Native? Lecture 2: Kabanero Overview Lecture 3: Adding value with IBM Cloud Pak for Applications Lecture 4: Customizing Appsody and Kabanero Lecture 5: Tekton Overview","title":"Lectures"},{"location":"resources/#links","text":"IBM Developer Appsody Documentation Kabanero Documentation Codewind Documentation Cloud Pak for Applications","title":"Links"}]}